<!DOCTYPE html>
<html>
<head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
<link rel='stylesheet' href='style.css' type='text/css'>
</head>
<body class='pyfile'>
<p>============================= test session starts ==============================</p>
<p>platform darwin -- Python 3.11.6, pytest-7.4.2, pluggy-1.3.0 -- /Users/eduardfer/Desktop/TFG TELEMÀTICA/eGym-server/dev-env/bin/python3.11</p>
<p>cachedir: .pytest_cache</p>
<p>rootdir: /Users/eduardfer/Desktop/TFG TELEMÀTICA/eGym-server</p>
<p>configfile: pyproject.toml</p>
<p>plugins: emoji-0.2.0, order-1.1.0, cov-4.1.0, asyncio-0.21.1, anyio-3.7.1, xdist-3.3.1</p>
<p>asyncio: mode=Mode.AUTO</p>
<p>collecting ... collected 154 items</p>
<p>                                                                                                         </p>
<p>src/tests/routers/posts_test.py::test_getPosts_NoContent FAILED ❌                                  [  0%]</p>
<p>src/tests/routers/posts_test.py::test_getPostById_BadRequest FAILED ❌                              [  1%]</p>
<p>src/tests/routers/posts_test.py::test_getPostById_NotFound FAILED ❌                                [  1%]</p>
<p>src/tests/routers/posts_test.py::test_getPostByCreator_NotFound FAILED ❌                           [  2%]</p>
<p>src/tests/routers/routines_test.py::test_getRoutines_NoContent FAILED ❌                            [  3%]</p>
<p>src/tests/routers/routines_test.py::test_getRoutineById_BadRequest FAILED ❌                        [  3%]</p>
<p>src/tests/routers/routines_test.py::test_getRoutineById_NotFound FAILED ❌                          [  4%]</p>
<p>src/tests/routers/routines_test.py::test_getRoutineByCreator_NotFound FAILED ❌                     [  5%]</p>
<p>src/tests/routers/usersTO_test.py::test_getUsersTO_NoContent FAILED ❌                              [  5%]</p>
<p>src/tests/routers/usersTO_test.py::test_getUserTOById_BadRequest FAILED ❌                          [  6%]</p>
<p>src/tests/routers/usersTO_test.py::test_getUserTOById_NotFound FAILED ❌                            [  7%]</p>
<p>src/tests/routers/usersTO_test.py::test_getUserTOByUsername_NotFound FAILED ❌                      [  7%]</p>
<p>src/tests/routers/usersTO_test.py::test_addUserTO_Created PASSED ✅                                 [  8%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_getExercisesTO_NoContent FAILED ❌                      [  9%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_BadRequest FAILED ❌                  [  9%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_NotFound FAILED ❌                    [ 10%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_NotFound FAILED ❌              [ 11%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_NoContent FAILED ❌             [ 11%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_getExerciseTOByName_NotFound FAILED ❌                  [ 12%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_addExerciseTO_NotFoundUserTO FAILED ❌                  [ 12%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_addExerciseTO_Created FAILED ❌                         [ 13%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_addExerciseTO_Conflict FAILED ❌                        [ 14%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_getExerciseTO_Ok FAILED ❌                              [ 14%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_Ok FAILED ❌                          [ 15%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_Ok FAILED ❌                    [ 16%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_getExerciseTOByName_Ok FAILED ❌                        [ 16%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_BadRequest FAILED ❌                   [ 17%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_NotFound FAILED ❌                     [ 18%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_Conflict FAILED ❌                     [ 18%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_Ok FAILED ❌                           [ 19%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_BadRequest FAILED ❌                   [ 20%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_NotFound FAILED ❌                     [ 20%]</p>
<p>src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_Ok FAILED ❌                           [ 21%]</p>
<p>src/tests/routers/routinesTO_test.py::test_getRoutinesTO_NoContent FAILED ❌                        [ 22%]</p>
<p>src/tests/routers/routinesTO_test.py::test_getRoutineTOById_BadRequest FAILED ❌                    [ 22%]</p>
<p>src/tests/routers/routinesTO_test.py::test_getRoutineTOById_NotFound FAILED ❌                      [ 23%]</p>
<p>src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_NotFound FAILED ❌                [ 24%]</p>
<p>src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_NoContent FAILED ❌               [ 24%]</p>
<p>src/tests/routers/routinesTO_test.py::test_getRoutinesTOByName_NotFound FAILED ❌                   [ 25%]</p>
<p>src/tests/routers/routinesTO_test.py::test_addRoutineTO_NotFoundUserTO FAILED ❌                    [ 25%]</p>
<p>src/tests/routers/routinesTO_test.py::test_addRoutineTO_Created FAILED ❌                           [ 26%]</p>
<p>src/tests/routers/routinesTO_test.py::test_getRoutineTO_Ok FAILED ❌                                [ 27%]</p>
<p>src/tests/routers/routinesTO_test.py::test_getRoutineTOById_Ok FAILED ❌                            [ 27%]</p>
<p>src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_Ok FAILED ❌                      [ 28%]</p>
<p>src/tests/routers/routinesTO_test.py::test_getRoutinesTOByName_Ok FAILED ❌                         [ 29%]</p>
<p>src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_BadRequestRoutineId FAILED ❌   [ 29%]</p>
<p>src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_BadRequestExerciseId FAILED ❌  [ 30%]</p>
<p>src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_NotFoundRoutineId FAILED ❌     [ 31%]</p>
<p>src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_NotFoundExerciseId FAILED ❌    [ 31%]</p>
<p>src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_Ok FAILED ❌                    [ 32%]</p>
<p>src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_Conflict FAILED ❌              [ 33%]</p>
<p>src/tests/routers/routinesTO_test.py::test_updateRoutineTO_BadRequest FAILED ❌                     [ 33%]</p>
<p>src/tests/routers/routinesTO_test.py::test_updateRoutineTO_NotFound FAILED ❌                       [ 34%]</p>
<p>src/tests/routers/routinesTO_test.py::test_updateRoutineTO_Ok FAILED ❌                             [ 35%]</p>
<p>src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_BadRequest FAILED ❌                     [ 35%]</p>
<p>src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_NotFound FAILED ❌                       [ 36%]</p>
<p>src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_Ok FAILED ❌                             [ 37%]</p>
<p>src/tests/routers/usersTO_test.py::test_addUserTO_Conflict PASSED ✅                                [ 37%]</p>
<p>src/tests/routers/usersTO_test.py::test_getUserTO_Ok FAILED ❌                                      [ 38%]</p>
<p>src/tests/routers/usersTO_test.py::test_getUserTOById_Ok FAILED ❌                                  [ 38%]</p>
<p>src/tests/routers/usersTO_test.py::test_getUserTOByUsername_Ok FAILED ❌                            [ 39%]</p>
<p>src/tests/routers/usersTO_test.py::test_updateUserTO_BadRequest FAILED ❌                           [ 40%]</p>
<p>src/tests/routers/usersTO_test.py::test_updateUserTO_NotFound FAILED ❌                             [ 40%]</p>
<p>src/tests/routers/usersTO_test.py::test_updateUserTO_Conflict FAILED ❌                             [ 41%]</p>
<p>src/tests/routers/usersTO_test.py::test_updateUserTO_Ok FAILED ❌                                   [ 42%]</p>
<p>src/tests/routers/usersTO_test.py::test_deleteUserTO_BadRequest FAILED ❌                           [ 42%]</p>
<p>src/tests/routers/usersTO_test.py::test_deleteUserTO_NotFound FAILED ❌                             [ 43%]</p>
<p>src/tests/routers/usersTO_test.py::test_deleteUserTO_Ok FAILED ❌                                   [ 44%]</p>
<p>src/tests/routers/users_test.py::test_addUser_Created FAILED ❌                                     [ 44%]</p>
<p>src/tests/routers/posts_test.py::test_getPostByCreator_NoContent FAILED ❌                          [ 45%]</p>
<p>src/tests/routers/posts_test.py::test_addPost_NotFound FAILED ❌                                    [ 46%]</p>
<p>src/tests/routers/posts_test.py::test_addPost_Created FAILED ❌                                     [ 46%]</p>
<p>src/tests/routers/comments_test.py::test_getComments_NoContent FAILED ❌                            [ 47%]</p>
<p>src/tests/routers/comments_test.py::test_getCommentById_BadRequest FAILED ❌                        [ 48%]</p>
<p>src/tests/routers/comments_test.py::test_getCommentById_NotFound FAILED ❌                          [ 48%]</p>
<p>src/tests/routers/comments_test.py::test_getCommentsByCreator_NotFound FAILED ❌                    [ 49%]</p>
<p>src/tests/routers/comments_test.py::test_getCommentsByCreator_NoContent FAILED ❌                   [ 50%]</p>
<p>src/tests/routers/comments_test.py::test_getPostComments_BadRequest FAILED ❌                       [ 50%]</p>
<p>src/tests/routers/comments_test.py::test_getPostComments_NotFound FAILED ❌                         [ 51%]</p>
<p>src/tests/routers/comments_test.py::test_getPostComments_NoContent FAILED ❌                        [ 51%]</p>
<p>src/tests/routers/comments_test.py::test_addCommentToPost_PostIdBadRequest FAILED ❌                [ 52%]</p>
<p>src/tests/routers/comments_test.py::test_addCommentToPost_PostNotFound FAILED ❌                    [ 53%]</p>
<p>src/tests/routers/comments_test.py::test_addCommentToPost_UserNotFound FAILED ❌                    [ 53%]</p>
<p>src/tests/routers/comments_test.py::test_addCommentToPost_Ok FAILED ❌                              [ 54%]</p>
<p>src/tests/routers/comments_test.py::test_getComments_Ok FAILED ❌                                   [ 55%]</p>
<p>src/tests/routers/comments_test.py::test_getCommentById_Ok FAILED ❌                                [ 55%]</p>
<p>src/tests/routers/comments_test.py::test_getCommentsByCreator_Ok FAILED ❌                          [ 56%]</p>
<p>src/tests/routers/comments_test.py::test_getPostComments_Ok FAILED ❌                               [ 57%]</p>
<p>src/tests/routers/comments_test.py::test_udpateCommentFromPost_BadRequest FAILED ❌                 [ 57%]</p>
<p>src/tests/routers/comments_test.py::test_udpateCommentFromPost_CommentNotFound FAILED ❌            [ 58%]</p>
<p>src/tests/routers/comments_test.py::test_udpateCommentFromPost_PostNotFound FAILED ❌               [ 59%]</p>
<p>src/tests/routers/comments_test.py::test_udpateCommentFromPost_UserNotFound FAILED ❌               [ 59%]</p>
<p>src/tests/routers/comments_test.py::test_udpateCommentFromPost_Ok FAILED ❌                         [ 60%]</p>
<p>src/tests/routers/comments_test.py::test_deleteCommentFromPost_BadRequest FAILED ❌                 [ 61%]</p>
<p>src/tests/routers/comments_test.py::test_deleteCommentFromPost_CommentNotFound FAILED ❌            [ 61%]</p>
<p>src/tests/routers/comments_test.py::test_deleteCommentFromPost_Ok FAILED ❌                         [ 62%]</p>
<p>src/tests/routers/comments_test.py::test_deleteAllPostComments_BadRequest FAILED ❌                 [ 62%]</p>
<p>src/tests/routers/comments_test.py::test_deleteAllPostComments_NotFound FAILED ❌                   [ 63%]</p>
<p>src/tests/routers/comments_test.py::test_deleteAllPostComments_Ok FAILED ❌                         [ 64%]</p>
<p>src/tests/routers/comments_test.py::test_deleteAllPostComments_NoContent FAILED ❌                  [ 64%]</p>
<p>src/tests/routers/posts_test.py::test_getPosts_Ok FAILED ❌                                         [ 65%]</p>
<p>src/tests/routers/posts_test.py::test_getPostById_Ok FAILED ❌                                      [ 66%]</p>
<p>src/tests/routers/posts_test.py::test_getPostsByCreator_Ok FAILED ❌                                [ 66%]</p>
<p>src/tests/routers/posts_test.py::test_updatePost_BadRequest FAILED ❌                               [ 67%]</p>
<p>src/tests/routers/posts_test.py::test_updatePost_NotFound FAILED ❌                                 [ 68%]</p>
<p>src/tests/routers/posts_test.py::test_updatePost_NoContent FAILED ❌                                [ 68%]</p>
<p>src/tests/routers/posts_test.py::test_updatePost_User_NotFound FAILED ❌                            [ 69%]</p>
<p>src/tests/routers/posts_test.py::test_updatePost_Created FAILED ❌                                  [ 70%]</p>
<p>src/tests/routers/posts_test.py::test_deletePost_BadRequest FAILED ❌                               [ 70%]</p>
<p>src/tests/routers/posts_test.py::test_deletePost_NotFound FAILED ❌                                 [ 71%]</p>
<p>src/tests/routers/posts_test.py::test_deletePost_Ok FAILED ❌                                       [ 72%]</p>
<p>src/tests/routers/posts_test.py::test_deleteAllCreatorPosts_NotFound FAILED ❌                      [ 72%]</p>
<p>src/tests/routers/posts_test.py::test_deleteAllCreatorPosts_Ok FAILED ❌                            [ 73%]</p>
<p>src/tests/routers/routines_test.py::test_getRoutineByCreator_NoContent FAILED ❌                    [ 74%]</p>
<p>src/tests/routers/routines_test.py::test_addRoutine_NotFound FAILED ❌                              [ 74%]</p>
<p>src/tests/routers/routines_test.py::test_addRoutine_Created FAILED ❌                               [ 75%]</p>
<p>src/tests/routers/routines_test.py::test_getRoutines_Ok FAILED ❌                                   [ 75%]</p>
<p>src/tests/routers/routines_test.py::test_getRoutineById_Ok FAILED ❌                                [ 76%]</p>
<p>src/tests/routers/routines_test.py::test_getRoutinesByCreator_Ok FAILED ❌                          [ 77%]</p>
<p>src/tests/routers/routines_test.py::test_updateRoutine_BadRequest FAILED ❌                         [ 77%]</p>
<p>src/tests/routers/routines_test.py::test_updateRoutine_NotFound FAILED ❌                           [ 78%]</p>
<p>src/tests/routers/routines_test.py::test_updateRoutine_NoContent FAILED ❌                          [ 79%]</p>
<p>src/tests/routers/routines_test.py::test_updateRoutine_UserNotFound FAILED ❌                       [ 79%]</p>
<p>src/tests/routers/routines_test.py::test_updateRoutine_Created FAILED ❌                            [ 80%]</p>
<p>src/tests/routers/routines_test.py::test_deleteRoutine_BadRequest FAILED ❌                         [ 81%]</p>
<p>src/tests/routers/routines_test.py::test_deleteRoutine_NotFound FAILED ❌                           [ 81%]</p>
<p>src/tests/routers/routines_test.py::test_deleteRoutine_Ok FAILED ❌                                 [ 82%]</p>
<p>src/tests/routers/routines_test.py::test_deleteAllCreatorRoutines_NotFound FAILED ❌                [ 83%]</p>
<p>src/tests/routers/routines_test.py::test_deleteAllCreatorRoutines_Ok FAILED ❌                      [ 83%]</p>
<p>src/tests/routers/users_test.py::test_getPublicUsers_BadRequest FAILED ❌                           [ 84%]</p>
<p>src/tests/routers/users_test.py::test_getPublicUsers_All_Ok FAILED ❌                               [ 85%]</p>
<p>src/tests/routers/users_test.py::test_getPublicUsers_ById_Ok FAILED ❌                              [ 85%]</p>
<p>src/tests/routers/users_test.py::test_getPublicUsers_ByUsername_Ok FAILED ❌                        [ 86%]</p>
<p>src/tests/routers/users_test.py::test_followUser_Ok FAILED ❌                                       [ 87%]</p>
<p>src/tests/routers/users_test.py::test_followUser_NoContent FAILED ❌                                [ 87%]</p>
<p>src/tests/routers/users_test.py::test_unfollowUser_Ok FAILED ❌                                     [ 88%]</p>
<p>src/tests/routers/users_test.py::test_unfollowUser_NoContent FAILED ❌                              [ 88%]</p>
<p>src/tests/routers/users_test.py::test_getUsers_Ok FAILED ❌                                         [ 89%]</p>
<p>src/tests/routers/users_test.py::test_addUser_Conflict PASSED ✅                                    [ 90%]</p>
<p>src/tests/routers/users_test.py::test_getUserById_Ok FAILED ❌                                      [ 90%]</p>
<p>src/tests/routers/users_test.py::test_getUserById_BadRequest FAILED ❌                              [ 91%]</p>
<p>src/tests/routers/users_test.py::test_getUserById_NotFound FAILED ❌                                [ 92%]</p>
<p>src/tests/routers/users_test.py::test_getUserByUsername_Ok FAILED ❌                                [ 92%]</p>
<p>src/tests/routers/users_test.py::test_updateUser_NoContent FAILED ❌                                [ 93%]</p>
<p>src/tests/routers/users_test.py::test_updateUser_Ok FAILED ❌                                       [ 94%]</p>
<p>src/tests/routers/users_test.py::test_getUserByUsername_NotFound FAILED ❌                          [ 94%]</p>
<p>src/tests/routers/users_test.py::test_updateUser_BadRequest FAILED ❌                               [ 95%]</p>
<p>src/tests/routers/users_test.py::test_updateUser_NotFound FAILED ❌                                 [ 96%]</p>
<p>src/tests/routers/users_test.py::test_updateUser_Conflict FAILED ❌                                 [ 96%]</p>
<p>src/tests/routers/users_test.py::test_deleteUser_Ok FAILED ❌                                       [ 97%]</p>
<p>src/tests/routers/users_test.py::test_deleteUser_BadRequest FAILED ❌                               [ 98%]</p>
<p>src/tests/routers/users_test.py::test_deleteUser_NotFound FAILED ❌                                 [ 98%]</p>
<p>src/tests/routers/users_test.py::test_deleteAllUsers_Ok FAILED ❌                                   [ 99%]</p>
<p>src/tests/routers/users_test.py::test_getUsers_NoContent FAILED ❌                                  [100%]</p>
<p></p>
<p>=================================== FAILURES ===================================</p>
<p>___________________________ test_getPosts_NoContent ____________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPosts_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await posts.getPosts()</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/posts_test.py:38: AssertionError</p>
<p>_________________________ test_getPostById_BadRequest __________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPostById_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await posts.getPostById("id_is_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/posts_test.py:46: AssertionError</p>
<p>__________________________ test_getPostById_NotFound ___________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPostById_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await posts.getPostById(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/posts_test.py:54: AssertionError</p>
<p>________________________ test_getPostByCreator_NotFound ________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPostByCreator_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await posts.getPostsByCreator("eduardferre")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/posts_test.py:62: AssertionError</p>
<p>__________________________ test_getRoutines_NoContent __________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutines_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routines.getRoutines()</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routines_test.py:62: AssertionError</p>
<p>________________________ test_getRoutineById_BadRequest ________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutineById_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routines.getRoutineById("id_is_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routines_test.py:70: AssertionError</p>
<p>_________________________ test_getRoutineById_NotFound _________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutineById_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routines.getRoutineById(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routines_test.py:78: AssertionError</p>
<p>______________________ test_getRoutineByCreator_NotFound _______________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutineByCreator_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routines.getRoutinesByCreator("eduardferre")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routines_test.py:86: AssertionError</p>
<p>__________________________ test_getUsersTO_NoContent ___________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUsersTO_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await usersTO.getUsersTO()</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:39: AssertionError</p>
<p>________________________ test_getUserTOById_BadRequest _________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserTOById_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await usersTO.getUserTOById("id_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:47: AssertionError</p>
<p>_________________________ test_getUserTOById_NotFound __________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserTOById_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await usersTO.getUserTOById(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:55: AssertionError</p>
<p>______________________ test_getUserTOByUsername_NotFound _______________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserTOByUsername_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await usersTO.getUserTOByUsername("eduardferre")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:63: AssertionError</p>
<p>________________________ test_getExercisesTO_NoContent _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getExercisesTO_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.getExercisesTO()</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:38: AssertionError</p>
<p>______________________ test_getExerciseTOById_BadRequest _______________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getExerciseTOById_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.getExerciseTOById("id_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:47: AssertionError</p>
<p>_______________________ test_getExerciseTOById_NotFound ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getExerciseTOById_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.getExerciseTOById(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:56: AssertionError</p>
<p>____________________ test_getExercisesTOByCreator_NotFound _____________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getExercisesTOByCreator_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.getExercisesTOByCreator("not_found_user")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:65: AssertionError</p>
<p>____________________ test_getExercisesTOByCreator_NoContent ____________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getExercisesTOByCreator_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.getExercisesTOByCreator("eduardferre")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:74: AssertionError</p>
<p>______________________ test_getExerciseTOByName_NotFound _______________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getExerciseTOByName_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.getExerciseTOByName("not_found")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:83: AssertionError</p>
<p>______________________ test_addExerciseTO_NotFoundUserTO _______________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addExerciseTO_NotFoundUserTO():</p>
<p>        exercise_not_found_user = exerciseTO_add.model_copy()</p>
<p>        exercise_not_found_user.creator = "test21"</p>
<p>    </p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.addExerciseTO(exercise_not_found_user)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:95: AssertionError</p>
<p>__________________________ test_addExerciseTO_Created __________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addExerciseTO_Created():</p>
<p>>       exercise_response = await exercisesTO.addExerciseTO(exerciseTO_add)</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:101: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/exercisesTO.py:150: in addExerciseTO</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/exercisesTO.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_________________________ test_addExerciseTO_Conflict __________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addExerciseTO_Conflict():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.addExerciseTO(exerciseTO_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 409</p>
<p>E       AssertionError: assert 401 == 409</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:113: AssertionError</p>
<p>____________________________ test_getExerciseTO_Ok _____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getExerciseTO_Ok():</p>
<p>>       exercises_list = await exercisesTO.getExercisesTO()</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:119: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/exercisesTO.py:36: in getExercisesTO</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/exercisesTO.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>__________________________ test_getExerciseTOById_Ok ___________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getExerciseTOById_Ok():</p>
<p>>       exercise_response = await exercisesTO.getExerciseTOById(exerciseTO_add.id)</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:127: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/exercisesTO.py:61: in getExerciseTOById</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/exercisesTO.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_______________________ test_getExercisesTOByCreator_Ok ________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getExercisesTOByCreator_Ok():</p>
<p>>       exercises_list = await exercisesTO.getExercisesTOByCreator("eduardferre")</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:135: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/exercisesTO.py:93: in getExercisesTOByCreator</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/exercisesTO.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_________________________ test_getExerciseTOByName_Ok __________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getExerciseTOByName_Ok():</p>
<p>>       exercise_response = await exercisesTO.getExerciseTOByName("Dead Lift")</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:143: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/exercisesTO.py:129: in getExerciseTOByName</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/exercisesTO.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_______________________ test_updateExerciseTO_BadRequest _______________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateExerciseTO_BadRequest():</p>
<p>        exercise_not_valid_id = exerciseTO_add.model_copy()</p>
<p>        exercise_not_valid_id.id = "not_valid_id"</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.updateExerciseTO(exercise_not_valid_id)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:156: AssertionError</p>
<p>________________________ test_updateExerciseTO_NotFound ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateExerciseTO_NotFound():</p>
<p>        exercise_not_found = exerciseTO_add.model_copy()</p>
<p>        exercise_not_found.id = id_test_404</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.updateExerciseTO(exercise_not_found)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:167: AssertionError</p>
<p>________________________ test_updateExerciseTO_Conflict ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateExerciseTO_Conflict():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.updateExerciseTO(exerciseTO_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 409</p>
<p>E       AssertionError: assert 401 == 409</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:176: AssertionError</p>
<p>___________________________ test_updateExerciseTO_Ok ___________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateExerciseTO_Ok():</p>
<p>        exercise_update = exerciseTO_add.model_copy()</p>
<p>        exercise_update.name = "Squat"</p>
<p>>       exercise_response = await exercisesTO.updateExerciseTO(exercise_update)</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:184: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/exercisesTO.py:191: in updateExerciseTO</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/exercisesTO.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_______________________ test_deleteExerciseTO_BadRequest _______________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteExerciseTO_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.deleteExerciseTO("not_valid_id")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:196: AssertionError</p>
<p>________________________ test_deleteExerciseTO_NotFound ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteExerciseTO_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await exercisesTO.deleteExerciseTO(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:205: AssertionError</p>
<p>___________________________ test_deleteExerciseTO_Ok ___________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteExerciseTO_Ok():</p>
<p>>       exercise_to_delete = await exercisesTO.getExercisesTOByCreator("eduardferre")</p>
<p></p>
<p>src/tests/routers/exercisesTO_test.py:211: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/exercisesTO.py:93: in getExercisesTOByCreator</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/exercisesTO.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_________________________ test_getRoutinesTO_NoContent _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutinesTO_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.getRoutinesTO()</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:48: AssertionError</p>
<p>_______________________ test_getRoutineTOById_BadRequest _______________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutineTOById_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.getRoutineTOById("id_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:57: AssertionError</p>
<p>________________________ test_getRoutineTOById_NotFound ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutineTOById_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.getRoutineTOById(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:66: AssertionError</p>
<p>_____________________ test_getRoutinesTOByCreator_NotFound _____________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutinesTOByCreator_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.getRoutinesTOByCreator("not_found_user")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:75: AssertionError</p>
<p>____________________ test_getRoutinesTOByCreator_NoContent _____________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutinesTOByCreator_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.getRoutinesTOByCreator("eduardferre")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:84: AssertionError</p>
<p>______________________ test_getRoutinesTOByName_NotFound _______________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutinesTOByName_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.getRoutinesTOByName("not_found")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:93: AssertionError</p>
<p>_______________________ test_addRoutineTO_NotFoundUserTO _______________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addRoutineTO_NotFoundUserTO():</p>
<p>        routine_not_found_user = routineTO_add.model_copy()</p>
<p>        routine_not_found_user.creator = "test21"</p>
<p>    </p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.addRoutineTO(routine_not_found_user)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:105: AssertionError</p>
<p>__________________________ test_addRoutineTO_Created ___________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addRoutineTO_Created():</p>
<p>>       routine_response = await routinesTO.addRoutineTO(routineTO_add)</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:111: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routinesTO.py:165: in addRoutineTO</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routinesTO.py:25: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_____________________________ test_getRoutineTO_Ok _____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutineTO_Ok():</p>
<p>>       routines_list = await routinesTO.getRoutinesTO()</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:120: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routinesTO.py:37: in getRoutinesTO</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routinesTO.py:25: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>___________________________ test_getRoutineTOById_Ok ___________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutineTOById_Ok():</p>
<p>>       routine_response = await routinesTO.getRoutineTOById(routineTO_add.id)</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:128: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routinesTO.py:66: in getRoutineTOById</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routinesTO.py:25: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>________________________ test_getRoutinesTOByCreator_Ok ________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutinesTOByCreator_Ok():</p>
<p>>       routines_list = await routinesTO.getRoutinesTOByCreator("eduardferre")</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:136: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routinesTO.py:97: in getRoutinesTOByCreator</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routinesTO.py:25: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_________________________ test_getRoutinesTOByName_Ok __________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutinesTOByName_Ok():</p>
<p>>       routines_list = await routinesTO.getRoutinesTOByName("LegDay")</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:144: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routinesTO.py:137: in getRoutinesTOByName</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routinesTO.py:25: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>______________ test_addExerciseTOToRoutineTO_BadRequestRoutineId _______________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addExerciseTOToRoutineTO_BadRequestRoutineId():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.addExerciseTOToRoutineTO("id_not_valid", "id_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:155: AssertionError</p>
<p>______________ test_addExerciseTOToRoutineTO_BadRequestExerciseId ______________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addExerciseTOToRoutineTO_BadRequestExerciseId():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.addExerciseTOToRoutineTO(id_test_404, "id_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:164: AssertionError</p>
<p>_______________ test_addExerciseTOToRoutineTO_NotFoundRoutineId ________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addExerciseTOToRoutineTO_NotFoundRoutineId():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.addExerciseTOToRoutineTO(id_test_404, id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:173: AssertionError</p>
<p>_______________ test_addExerciseTOToRoutineTO_NotFoundExerciseId _______________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addExerciseTOToRoutineTO_NotFoundExerciseId():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.addExerciseTOToRoutineTO(routineTO_add.id, id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:182: AssertionError</p>
<p>_______________________ test_addExerciseTOToRoutineTO_Ok _______________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addExerciseTOToRoutineTO_Ok():</p>
<p>>       exercise_response = await exercisesTO.addExerciseTO(exerciseTO_add)</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:188: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/exercisesTO.py:150: in addExerciseTO</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/exercisesTO.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107985990></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>____________________ test_addExerciseTOToRoutineTO_Conflict ____________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addExerciseTOToRoutineTO_Conflict():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.addExerciseTOToRoutineTO(routineTO_add.id, exerciseTO_add.id)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 409</p>
<p>E       AssertionError: assert 401 == 409</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:205: AssertionError</p>
<p>_______________________ test_updateRoutineTO_BadRequest ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateRoutineTO_BadRequest():</p>
<p>        routine_not_valid_id = routineTO_add.model_copy()</p>
<p>        routine_not_valid_id.id = "not_valid_id"</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.updateRoutineTO(routine_not_valid_id)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:216: AssertionError</p>
<p>________________________ test_updateRoutineTO_NotFound _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateRoutineTO_NotFound():</p>
<p>        routine_not_found = routineTO_add.model_copy()</p>
<p>        routine_not_found.id = id_test_404</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.updateRoutineTO(routine_not_found)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:227: AssertionError</p>
<p>___________________________ test_updateRoutineTO_Ok ____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateRoutineTO_Ok():</p>
<p>        routine_update = routineTO_add.model_copy()</p>
<p>        routine_update.description = "eduardfer"</p>
<p>>       routine_response = await routinesTO.updateRoutineTO(routine_update)</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:235: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routinesTO.py:266: in updateRoutineTO</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routinesTO.py:25: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_______________________ test_deleteRoutineTO_BadRequest ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteRoutineTO_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.deleteRoutineTO("not_valid_id")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:247: AssertionError</p>
<p>________________________ test_deleteRoutineTO_NotFound _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteRoutineTO_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routinesTO.deleteRoutineTO(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:256: AssertionError</p>
<p>___________________________ test_deleteRoutineTO_Ok ____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteRoutineTO_Ok():</p>
<p>>       routine_to_delete = await routinesTO.getRoutinesTOByCreator("eduardferre")</p>
<p></p>
<p>src/tests/routers/routinesTO_test.py:262: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routinesTO.py:97: in getRoutinesTOByCreator</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routinesTO.py:25: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x10799ca10></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>______________________________ test_getUserTO_Ok _______________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1047c2a50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserTO_Ok():</p>
<p>>       users_list = await usersTO.getUsersTO()</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:88: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/usersTO.py:39: in getUsersTO</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/usersTO.py:27: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1047c2a50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>____________________________ test_getUserTOById_Ok _____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1047c2a50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserTOById_Ok():</p>
<p>>       user_response = await usersTO.getUserTOById(userTO_add.id)</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:95: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/usersTO.py:67: in getUserTOById</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/usersTO.py:27: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1047c2a50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_________________________ test_getUserTOByUsername_Ok __________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1047c2a50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserTOByUsername_Ok():</p>
<p>>       user_response = await usersTO.getUserTOByUsername("eduardferre")</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:102: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/usersTO.py:118: in getUserTOByUsername</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/usersTO.py:27: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1047c2a50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_________________________ test_updateUserTO_BadRequest _________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateUserTO_BadRequest():</p>
<p>        user_not_valid_id = userTO_add.model_copy()</p>
<p>        user_not_valid_id.id = "not_valid_id"</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await usersTO.updateUserTO(user_not_valid_id)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:114: AssertionError</p>
<p>__________________________ test_updateUserTO_NotFound __________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateUserTO_NotFound():</p>
<p>        user_not_found = userTO_add.model_copy()</p>
<p>        user_not_found.id = id_test_404</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await usersTO.updateUserTO(user_not_found)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:124: AssertionError</p>
<p>__________________________ test_updateUserTO_Conflict __________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateUserTO_Conflict():</p>
<p>        user_not_found = userTO_add.model_copy()</p>
<p>        user_not_found.username = "test2"</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await usersTO.updateUserTO(user_not_found)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 409</p>
<p>E       AssertionError: assert 401 == 409</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:134: AssertionError</p>
<p>_____________________________ test_updateUserTO_Ok _____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1047c2a50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateUserTO_Ok():</p>
<p>        user_update = userTO_add.model_copy()</p>
<p>        user_update.username = "eduardfer"</p>
<p>>       user_response = await usersTO.updateUserTO(user_update)</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:141: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/usersTO.py:164: in updateUserTO</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/usersTO.py:27: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1047c2a50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_________________________ test_deleteUserTO_BadRequest _________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteUserTO_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await usersTO.deleteUserTO("not_valid_id")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:152: AssertionError</p>
<p>__________________________ test_deleteUserTO_NotFound __________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteUserTO_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await usersTO.deleteUserTO(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:160: AssertionError</p>
<p>_____________________________ test_deleteUserTO_Ok _____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1047c2a50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteUserTO_Ok():</p>
<p>>       user_to_delete = await usersTO.getUserTOByUsername("eduardfer")</p>
<p></p>
<p>src/tests/routers/usersTO_test.py:165: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/usersTO.py:118: in getUserTOByUsername</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/usersTO.py:27: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1047c2a50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_____________________________ test_addUser_Created _____________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addUser_Created():</p>
<p>>       user_response = await users.addUser(user=user_add)</p>
<p></p>
<p>src/tests/routers/users_test.py:67: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>user = User(id='507f1f77bcf86cd799439011', username='eduardferre', fullname='Eduard Ferré Sánchez', email='eduardferresanchez..., routinesLog=[], routines=[], profilePicture='https://blablabla', backgroundPicture='https://blablabla', public=False)</p>
<p></p>
<p>    async def addUser(user: User):</p>
<p>        # logging.info("POST /users/")</p>
<p>        user_search = await search_user("username", user.username)</p>
<p>    </p>
<p>        if type(user_search) == User:</p>
<p>            logging.info(f"The username '{user.username}' is already used")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_409_CONFLICT,</p>
<p>                detail=f"The username '{user.username}' is already used",</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/routers/users.py:183: HTTPException</p>
<p>----------------------------- Captured stderr call -----------------------------</p>
<p>[34;3mINFO:     2023-11-08 20:20:45,691 || The user with username = eduardferre exists in the database - (users.py:389)[0m</p>
<p>[34;3mINFO:     2023-11-08 20:20:45,691 || The username 'eduardferre' is already used - (users.py:182)[0m</p>
<p>------------------------------ Captured log call -------------------------------</p>
<p>INFO     eGym:users.py:389 The user with username = eduardferre exists in the database</p>
<p>INFO     eGym:users.py:182 The username 'eduardferre' is already used</p>
<p>_______________________ test_getPostByCreator_NoContent ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPostByCreator_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await posts.getPostsByCreator("eduardferre")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/posts_test.py:71: AssertionError</p>
<p>____________________________ test_addPost_NotFound _____________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addPost_NotFound():</p>
<p>        post_add.creator = "not_found"</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await posts.addPost(post_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/posts_test.py:81: AssertionError</p>
<p>_____________________________ test_addPost_Created _____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addPost_Created():</p>
<p>        post_add.creator = "eduardferre"</p>
<p>>       post_response = await posts.addPost(post_add)</p>
<p></p>
<p>src/tests/routers/posts_test.py:88: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/posts.py:97: in addPost</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/posts.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>__________________________ test_getComments_NoContent __________________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getComments_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.getComments()</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:31: AssertionError</p>
<p>________________________ test_getCommentById_BadRequest ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getCommentById_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.getCommentById("id_is_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:40: AssertionError</p>
<p>_________________________ test_getCommentById_NotFound _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getCommentById_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.getCommentById(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:49: AssertionError</p>
<p>______________________ test_getCommentsByCreator_NotFound ______________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getCommentsByCreator_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.getCommentsByCreator("user_not_found")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:58: AssertionError</p>
<p>_____________________ test_getCommentsByCreator_NoContent ______________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getCommentsByCreator_NoContent():</p>
<p>>       comments_list = await comments.getCommentsByCreator("eduardferre")</p>
<p></p>
<p>src/tests/routers/comments_test.py:64: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/comments.py:73: in getCommentsByCreator</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/comments.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_______________________ test_getPostComments_BadRequest ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPostComments_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.getPostComments("id_is_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:74: AssertionError</p>
<p>________________________ test_getPostComments_NotFound _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPostComments_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.getPostComments(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:83: AssertionError</p>
<p>________________________ test_getPostComments_NoContent ________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPostComments_NoContent():</p>
<p>        global post_response</p>
<p>>       post_response = await posts.getPostsByCreator("eduardferre")</p>
<p></p>
<p>src/tests/routers/comments_test.py:90: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/posts.py:73: in getPostsByCreator</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/posts.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>____________________ test_addCommentToPost_PostIdBadRequest ____________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addCommentToPost_PostIdBadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.addCommentToPost("is_not_valid_id", comment_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:103: AssertionError</p>
<p>______________________ test_addCommentToPost_PostNotFound ______________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addCommentToPost_PostNotFound():</p>
<p>        comment_add.postId = id_test_404</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.addCommentToPost(id_test_404, comment_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:119: AssertionError</p>
<p>______________________ test_addCommentToPost_UserNotFound ______________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addCommentToPost_UserNotFound():</p>
<p>>       comment_add.postId = post_response[0]["id"]</p>
<p>E       NameError: name 'post_response' is not defined</p>
<p></p>
<p>src/tests/routers/comments_test.py:125: NameError</p>
<p>___________________________ test_addCommentToPost_Ok ___________________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addCommentToPost_Ok():</p>
<p>>       comment_add.postId = post_response[0]["id"]</p>
<p>E       NameError: name 'post_response' is not defined</p>
<p></p>
<p>src/tests/routers/comments_test.py:136: NameError</p>
<p>_____________________________ test_getComments_Ok ______________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getComments_Ok():</p>
<p>>       comments_list = await comments.getComments()</p>
<p></p>
<p>src/tests/routers/comments_test.py:154: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/comments.py:35: in getComments</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/comments.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>____________________________ test_getCommentById_Ok ____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getCommentById_Ok():</p>
<p>>       comment_response = await comments.getCommentById(comment_add.id)</p>
<p></p>
<p>src/tests/routers/comments_test.py:162: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/comments.py:50: in getCommentById</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/comments.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_________________________ test_getCommentsByCreator_Ok _________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getCommentsByCreator_Ok():</p>
<p>>       comments_list = await comments.getCommentsByCreator("eduardferre")</p>
<p></p>
<p>src/tests/routers/comments_test.py:169: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/comments.py:73: in getCommentsByCreator</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/comments.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>___________________________ test_getPostComments_Ok ____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPostComments_Ok():</p>
<p>>       comments_list = await comments.getPostComments(comment_add.postId)</p>
<p></p>
<p>src/tests/routers/comments_test.py:179: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/comments.py:99: in getPostComments</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/comments.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>____________________ test_udpateCommentFromPost_BadRequest _____________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_udpateCommentFromPost_BadRequest():</p>
<p>        comment_400 = comment_add.copy()</p>
<p>    </p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.updateCommentFromPost("is_not_valid_id", comment_400)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:192: AssertionError</p>
<p>__________________ test_udpateCommentFromPost_CommentNotFound __________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_udpateCommentFromPost_CommentNotFound():</p>
<p>        comment_404 = comment_add.copy()</p>
<p>        comment_404.id = id_test_404</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.updateCommentFromPost(comment_404.postId, comment_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:220: AssertionError</p>
<p>___________________ test_udpateCommentFromPost_PostNotFound ____________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_udpateCommentFromPost_PostNotFound():</p>
<p>        comment_404 = comment_add.copy()</p>
<p>        comment_404.postId = id_test_404</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.updateCommentFromPost(comment_404.postId, comment_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:231: AssertionError</p>
<p>___________________ test_udpateCommentFromPost_UserNotFound ____________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_udpateCommentFromPost_UserNotFound():</p>
<p>        comment_404 = comment_add.copy()</p>
<p>        comment_404.creator = "user_not_found"</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.updateCommentFromPost(comment_404.postId, comment_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:242: AssertionError</p>
<p>________________________ test_udpateCommentFromPost_Ok _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_udpateCommentFromPost_Ok():</p>
<p>>       comment_duplicated.content = "This comment has been updated"</p>
<p>E       NameError: name 'comment_duplicated' is not defined</p>
<p></p>
<p>src/tests/routers/comments_test.py:248: NameError</p>
<p>____________________ test_deleteCommentFromPost_BadRequest _____________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteCommentFromPost_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.deleteCommentFromPost("is_not_valid_id", comment_add.id)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:264: AssertionError</p>
<p>__________________ test_deleteCommentFromPost_CommentNotFound __________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteCommentFromPost_CommentNotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.deleteCommentFromPost(comment_add.postId, id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:288: AssertionError</p>
<p>________________________ test_deleteCommentFromPost_Ok _________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteCommentFromPost_Ok():</p>
<p>>       comment_response = await comments.deleteCommentFromPost(</p>
<p>            comment_add.postId, comment_add.id</p>
<p>        )</p>
<p></p>
<p>src/tests/routers/comments_test.py:303: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/comments.py:288: in deleteCommentFromPost</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/comments.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>____________________ test_deleteAllPostComments_BadRequest _____________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteAllPostComments_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.deleteAllPostComments("id_is_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:329: AssertionError</p>
<p>_____________________ test_deleteAllPostComments_NotFound ______________________</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteAllPostComments_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await comments.deleteAllPostComments(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/comments_test.py:338: AssertionError</p>
<p>________________________ test_deleteAllPostComments_Ok _________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteAllPostComments_Ok():</p>
<p>>       post_comments_response = await comments.deleteAllPostComments(comment_add.postId)</p>
<p></p>
<p>src/tests/routers/comments_test.py:344: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/comments.py:362: in deleteAllPostComments</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/comments.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_____________________ test_deleteAllPostComments_NoContent _____________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="posts_test.py::test_addPost_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteAllPostComments_NoContent():</p>
<p>>       post_comments_response = await comments.deleteAllPostComments(comment_add.postId)</p>
<p></p>
<p>src/tests/routers/comments_test.py:353: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/comments.py:362: in deleteAllPostComments</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/comments.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107871d50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_______________________________ test_getPosts_Ok _______________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPosts_Ok():</p>
<p>>       posts_list = await posts.getPosts()</p>
<p></p>
<p>src/tests/routers/posts_test.py:98: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/posts.py:36: in getPosts</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/posts.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_____________________________ test_getPostById_Ok ______________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPostById_Ok():</p>
<p>>       post_response = await posts.getPostById(id_test_Ok)</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/posts_test.py:106: NameError</p>
<p>__________________________ test_getPostsByCreator_Ok ___________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPostsByCreator_Ok():</p>
<p>>       posts_list = await posts.getPostsByCreator("eduardferre")</p>
<p></p>
<p>src/tests/routers/posts_test.py:113: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/posts.py:73: in getPostsByCreator</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/posts.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>__________________________ test_updatePost_BadRequest __________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updatePost_BadRequest():</p>
<p>        post_add.id = "id_is_not_valid"</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await posts.updatePost(post_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/posts_test.py:136: AssertionError</p>
<p>___________________________ test_updatePost_NotFound ___________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updatePost_NotFound():</p>
<p>        post_add.id = id_test_404</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await posts.updatePost(post_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/posts_test.py:146: AssertionError</p>
<p>__________________________ test_updatePost_NoContent ___________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updatePost_NoContent():</p>
<p>        post_add.creator = "eduardferre"</p>
<p>>       post_add.id = id_test_Ok</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/posts_test.py:153: NameError</p>
<p>________________________ test_updatePost_User_NotFound _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updatePost_User_NotFound():</p>
<p>>       post_add.id = id_test_Ok</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/posts_test.py:163: NameError</p>
<p>___________________________ test_updatePost_Created ____________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updatePost_Created():</p>
<p>        post_add.creator = "eduardferre"</p>
<p>>       post_add.id = id_test_Ok</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/posts_test.py:175: NameError</p>
<p>__________________________ test_deletePost_BadRequest __________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deletePost_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await posts.deletePost("id_is_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/posts_test.py:187: AssertionError</p>
<p>___________________________ test_deletePost_NotFound ___________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deletePost_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await posts.deletePost(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/posts_test.py:196: AssertionError</p>
<p>______________________________ test_deletePost_Ok ______________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deletePost_Ok():</p>
<p>>       post_response = await posts.deletePost(id_test_Ok)</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/posts_test.py:202: NameError</p>
<p>_____________________ test_deleteAllCreatorPosts_NotFound ______________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteAllCreatorPosts_NotFound():</p>
<p>        post_add.creator = "eduardferre"</p>
<p>>       post_response = await posts.addPost(post_add)</p>
<p></p>
<p>src/tests/routers/posts_test.py:210: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/posts.py:97: in addPost</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/posts.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>________________________ test_deleteAllCreatorPosts_Ok _________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteAllCreatorPosts_Ok():</p>
<p>>       posts_list = await posts.deleteAllCreatorPosts("eduardferre")</p>
<p></p>
<p>src/tests/routers/posts_test.py:222: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/posts.py:271: in deleteAllCreatorPosts</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/posts.py:24: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x107870e90></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>______________________ test_getRoutineByCreator_NoContent ______________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutineByCreator_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routines.getRoutinesByCreator("eduardferre")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routines_test.py:95: AssertionError</p>
<p>___________________________ test_addRoutine_NotFound ___________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addRoutine_NotFound():</p>
<p>        routine_add.creator = "not_found"</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routines.addRoutine(routine_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routines_test.py:105: AssertionError</p>
<p>___________________________ test_addRoutine_Created ____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1078bcb50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_addRoutine_Created():</p>
<p>        routine_add.creator = "eduardferre"</p>
<p>>       routine_response = await routines.addRoutine(routine_add)</p>
<p></p>
<p>src/tests/routers/routines_test.py:112: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routines.py:96: in addRoutine</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routines.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1078bcb50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_____________________________ test_getRoutines_Ok ______________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1078bcb50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutines_Ok():</p>
<p>>       routines_list = await routines.getRoutines()</p>
<p></p>
<p>src/tests/routers/routines_test.py:121: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routines.py:35: in getRoutines</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routines.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1078bcb50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>____________________________ test_getRoutineById_Ok ____________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutineById_Ok():</p>
<p>>       routine_response = await routines.getRoutineById(id_test_Ok)</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/routines_test.py:129: NameError</p>
<p>_________________________ test_getRoutinesByCreator_Ok _________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1078bcb50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getRoutinesByCreator_Ok():</p>
<p>>       routines_list = await routines.getRoutinesByCreator("eduardferre")</p>
<p></p>
<p>src/tests/routers/routines_test.py:136: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routines.py:73: in getRoutinesByCreator</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routines.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1078bcb50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>________________________ test_updateRoutine_BadRequest _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateRoutine_BadRequest():</p>
<p>        routine_add.id = "id_is_not_valid"</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routines.updateRoutine(routine_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routines_test.py:152: AssertionError</p>
<p>_________________________ test_updateRoutine_NotFound __________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateRoutine_NotFound():</p>
<p>        routine_add.id = id_test_404</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routines.updateRoutine(routine_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routines_test.py:162: AssertionError</p>
<p>_________________________ test_updateRoutine_NoContent _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateRoutine_NoContent():</p>
<p>        routine_add.creator = "eduardferre"</p>
<p>>       routine_add.id = id_test_Ok</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/routines_test.py:169: NameError</p>
<p>_______________________ test_updateRoutine_UserNotFound ________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateRoutine_UserNotFound():</p>
<p>>       routine_add.id = id_test_Ok</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/routines_test.py:179: NameError</p>
<p>__________________________ test_updateRoutine_Created __________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateRoutine_Created():</p>
<p>        routine_add.creator = "eduardferre"</p>
<p>>       routine_add.id = id_test_Ok</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/routines_test.py:191: NameError</p>
<p>________________________ test_deleteRoutine_BadRequest _________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteRoutine_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routines.deleteRoutine("id_is_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routines_test.py:203: AssertionError</p>
<p>_________________________ test_deleteRoutine_NotFound __________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteRoutine_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await routines.deleteRoutine(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/routines_test.py:212: AssertionError</p>
<p>____________________________ test_deleteRoutine_Ok _____________________________</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteRoutine_Ok():</p>
<p>>       routine_response = await routines.deleteRoutine(id_test_Ok)</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/routines_test.py:218: NameError</p>
<p>____________________ test_deleteAllCreatorRoutines_NotFound ____________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1078bcb50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteAllCreatorRoutines_NotFound():</p>
<p>>       routine_response = await routines.addRoutine(routine_to_delete)</p>
<p></p>
<p>src/tests/routers/routines_test.py:225: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routines.py:96: in addRoutine</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routines.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1078bcb50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_______________________ test_deleteAllCreatorRoutines_Ok _______________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1078bcb50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(after="users_test.py::test_addUser_Created")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteAllCreatorRoutines_Ok():</p>
<p>>       routines_list = await routines.deleteAllCreatorRoutines("eduardferre")</p>
<p></p>
<p>src/tests/routers/routines_test.py:237: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/routines.py:277: in deleteAllCreatorRoutines</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/routines.py:23: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1078bcb50></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>________________________ test_getPublicUsers_BadRequest ________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPublicUsers_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.getPublicUsers("attribute_not_valid", "any")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:80: AssertionError</p>
<p>__________________________ test_getPublicUsers_All_Ok __________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPublicUsers_All_Ok():</p>
<p>>       user_list = await users.getPublicUsers("public", "users")</p>
<p></p>
<p>src/tests/routers/users_test.py:85: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/users.py:38: in getPublicUsers</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/users.py:22: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_________________________ test_getPublicUsers_ById_Ok __________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPublicUsers_ById_Ok():</p>
<p>>       user_list = await users.getPublicUsers("_id", user_add.id)</p>
<p></p>
<p>src/tests/routers/users_test.py:98: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/users.py:38: in getPublicUsers</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/users.py:22: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>______________________ test_getPublicUsers_ByUsername_Ok _______________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getPublicUsers_ByUsername_Ok():</p>
<p>>       user_list = await users.getPublicUsers("username", "eduardferre")</p>
<p></p>
<p>src/tests/routers/users_test.py:108: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/users.py:38: in getPublicUsers</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/users.py:22: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>______________________________ test_followUser_Ok ______________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_followUser_Ok():</p>
<p>>       user_add.following = await users.followUser(</p>
<p>            user_add.username, user_update_conflict.username</p>
<p>        )</p>
<p></p>
<p>src/tests/routers/users_test.py:117: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/users.py:76: in followUser</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/users.py:22: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>__________________________ test_followUser_NoContent ___________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_followUser_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.followUser(user_add.username, user_update_conflict.username)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:131: AssertionError</p>
<p>_____________________________ test_unfollowUser_Ok _____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_unfollowUser_Ok():</p>
<p>>       user_add.following = await users.unfollowUser(</p>
<p>            user_add.username, user_update_conflict.username</p>
<p>        )</p>
<p></p>
<p>src/tests/routers/users_test.py:136: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/users.py:104: in unfollowUser</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/users.py:22: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_________________________ test_unfollowUser_NoContent __________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_unfollowUser_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.unfollowUser(user_add.username, user_update_conflict.username)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:150: AssertionError</p>
<p>_______________________________ test_getUsers_Ok _______________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUsers_Ok():</p>
<p>>       users_list = await users.getUsers()</p>
<p></p>
<p>src/tests/routers/users_test.py:155: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/users.py:126: in getUsers</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/users.py:22: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>_____________________________ test_getUserById_Ok ______________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserById_Ok():</p>
<p>>       user_response = await users.getUserById(id_test_Ok)</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/users_test.py:170: NameError</p>
<p>_________________________ test_getUserById_BadRequest __________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserById_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.getUserById("id_test_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:179: AssertionError</p>
<p>__________________________ test_getUserById_NotFound ___________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserById_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.getUserById(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:187: AssertionError</p>
<p>__________________________ test_getUserByUsername_Ok ___________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserByUsername_Ok():</p>
<p>>       user_search = await users.getUserByUsername("eduardferre")</p>
<p></p>
<p>src/tests/routers/users_test.py:192: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/users.py:163: in getUserByUsername</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/users.py:22: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>__________________________ test_updateUser_NoContent ___________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateUser_NoContent():</p>
<p>>       user_add.id = id_test_Ok</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/users_test.py:198: NameError</p>
<p>______________________________ test_updateUser_Ok ______________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateUser_Ok():</p>
<p>        user_add.username = "eduardfer"</p>
<p>>       user_add.id = id_test_Ok</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/users_test.py:209: NameError</p>
<p>_______________________ test_getUserByUsername_NotFound ________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUserByUsername_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.getUserByUsername("eduardferre")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:220: AssertionError</p>
<p>__________________________ test_updateUser_BadRequest __________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateUser_BadRequest():</p>
<p>        user_add.id = "id_test_not_valid"</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.updateUser(user_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:229: AssertionError</p>
<p>___________________________ test_updateUser_NotFound ___________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateUser_NotFound():</p>
<p>        user_add.id = id_test_404</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.updateUser(user_add)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:238: AssertionError</p>
<p>___________________________ test_updateUser_Conflict ___________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_updateUser_Conflict():</p>
<p>        user_add.username = "aleixferre"</p>
<p>>       user_add.id = id_test_Ok</p>
<p>E       NameError: name 'id_test_Ok' is not defined</p>
<p></p>
<p>src/tests/routers/users_test.py:244: NameError</p>
<p>______________________________ test_deleteUser_Ok ______________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteUser_Ok():</p>
<p>>       user_search = await users.getUserByUsername("eduardfer")</p>
<p></p>
<p>src/tests/routers/users_test.py:253: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/users.py:163: in getUserByUsername</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/users.py:22: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>__________________________ test_deleteUser_BadRequest __________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteUser_BadRequest():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.deleteUser("id_test_not_valid")</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 400</p>
<p>E       AssertionError: assert 401 == 400</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:265: AssertionError</p>
<p>___________________________ test_deleteUser_NotFound ___________________________</p>
<p></p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteUser_NotFound():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.deleteUser(id_test_404)</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 404</p>
<p>E       AssertionError: assert 401 == 404</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:273: AssertionError</p>
<p>____________________________ test_deleteAllUsers_Ok ____________________________</p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p></p>
<p>src/main/services/auth.py:54: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode</p>
<p>    decoded = self.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete</p>
<p>    decoded = api_jws.decode_complete(</p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete</p>
<p>    payload, signing_input, header, signature = self._load(jwt)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <jwt.api_jws.PyJWS object at 0x10608f850></p>
<p>jwt = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:</p>
<p>        if isinstance(jwt, str):</p>
<p>            jwt = jwt.encode("utf-8")</p>
<p>    </p>
<p>        if not isinstance(jwt, bytes):</p>
<p>>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")</p>
<p>E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'></p>
<p></p>
<p>dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError</p>
<p></p>
<p>During handling of the above exception, another exception occurred:</p>
<p></p>
<p>    @pytest.mark.order(before="test_getUsers_NoContent")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_deleteAllUsers_Ok():</p>
<p>>       user_response = await users.deleteAllUsers()</p>
<p></p>
<p>src/tests/routers/users_test.py:279: </p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p>src/main/routers/users.py:371: in deleteAllUsers</p>
<p>    if token_validation(token) != None:</p>
<p>src/main/routers/users.py:22: in token_validation</p>
<p>    return auth_handler.decode_token(token)</p>
<p>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </p>
<p></p>
<p>self = <src.main.services.auth.Auth object at 0x1064da9d0></p>
<p>token = Depends(OAuth2PasswordBearer)</p>
<p></p>
<p>    def decode_token(self, token):</p>
<p>        try:</p>
<p>            pub_key = load_ES256_from_jwk_env().public_key()</p>
<p>            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))</p>
<p>            return decoded</p>
<p>        except jwt.ExpiredSignatureError:</p>
<p>            logging.info("The token has expired")</p>
<p>            raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"</p>
<p>            )</p>
<p>        except jwt.InvalidTokenError:</p>
<p>            logging.info("The token is invalid")</p>
<p>>           raise HTTPException(</p>
<p>                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"</p>
<p>            )</p>
<p>E           fastapi.exceptions.HTTPException</p>
<p></p>
<p>src/main/services/auth.py:63: HTTPException</p>
<p>___________________________ test_getUsers_NoContent ____________________________</p>
<p></p>
<p>    @pytest.mark.order("last")</p>
<p>    @pytest.mark.asyncio</p>
<p>    async def test_getUsers_NoContent():</p>
<p>        with pytest.raises(HTTPException) as exception:</p>
<p>            await users.getUsers()</p>
<p>        assert isinstance(exception.value, HTTPException)</p>
<p>>       assert exception.value.status_code == 204</p>
<p>E       AssertionError: assert 401 == 204</p>
<p>E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code</p>
<p>E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value</p>
<p></p>
<p>src/tests/routers/users_test.py:289: AssertionError</p>
<p></p>
<p>---------- coverage: platform darwin, python 3.11.6-final-0 ----------</p>
<p>Name                               Stmts   Miss  Cover   Missing</p>
<p>----------------------------------------------------------------</p>
<p>db/mongodb/client.py                  12      2    83%   12-13</p>
<p>db/mongodb/models/comment.py           8      0   100%</p>
<p>db/mongodb/models/exercise.py         12      0   100%</p>
<p>db/mongodb/models/post.py             18      3    83%   17-27</p>
<p>db/mongodb/models/routine.py          18      3    83%   17-26</p>
<p>db/mongodb/models/set.py               9      0   100%</p>
<p>db/mongodb/models/user.py             26      0   100%</p>
<p>db/mongodb/schemas/comment.py          4      2    50%   2, 11</p>
<p>db/mongodb/schemas/exercise.py         8      5    38%   5-9, 20</p>
<p>db/mongodb/schemas/post.py             4      2    50%   2, 14</p>
<p>db/mongodb/schemas/routine.py          8      4    50%   5-9</p>
<p>db/mongodb/schemas/set.py              7      5    29%   2-6, 17</p>
<p>db/mongodb/schemas/user.py             5      1    80%   28</p>
<p>db/sqlDB/client.py                     7      1    86%   7</p>
<p>db/sqlDB/models/exerciseTO.py          7      0   100%</p>
<p>db/sqlDB/models/routineTO.py           9      0   100%</p>
<p>db/sqlDB/models/userTO.py             10      0   100%</p>
<p>db/sqlDB/schemas/exerciseTO.py         4      2    50%   2, 10</p>
<p>db/sqlDB/schemas/routineTO.py          4      2    50%   2, 11</p>
<p>db/sqlDB/schemas/userTO.py             4      1    75%   13</p>
<p>src/main/__init__.py                   0      0   100%</p>
<p>src/main/main.py                      24      1    96%   41</p>
<p>src/main/models/user_register.py      24      0   100%</p>
<p>src/main/routers/__init__.py           0      0   100%</p>
<p>src/main/routers/comments.py         214    170    21%   36-45, 51-66, 74-92, 100-123, 133-193, 203-277, 289-353, 363-407, 412-417, 421-438</p>
<p>src/main/routers/exercisesTO.py      159    119    25%   20, 37-56, 62-84, 94-122, 130-145, 151-186, 192-229, 235-269, 274-281, 285-293, 297-301</p>
<p>src/main/routers/posts.py            187    146    22%   37-46, 52-66, 74-92, 98-144, 150-216, 222-264, 272-299, 304-309, 313-328</p>
<p>src/main/routers/routines.py         197    156    21%   36-45, 51-66, 74-91, 97-148, 154-228, 234-268, 278-305, 310-315, 319-336</p>
<p>src/main/routers/routinesTO.py       214    169    21%   21, 38-61, 67-90, 98-128, 138-160, 166-188, 198-261, 267-297, 303-336, 341-348, 352-364, 370-389, 393-397</p>
<p>src/main/routers/transactions.py      45     26    42%   27-36, 50-65, 79-94</p>
<p>src/main/routers/users.py            233    177    24%   39-69, 77-95, 105-121, 127-136, 142-158, 164-173, 188-202, 208-315, 321-366, 372-381, 391-392, 396-402</p>
<p>src/main/routers/usersTO.py          147     88    40%   40-62, 68-91, 95-111, 119, 145-149, 165-233, 239-282, 313-317</p>
<p>src/main/services/__init__.py          0      0   100%</p>
<p>src/main/services/auth.py             64     29    55%   31, 34, 37-44, 55, 57-58, 68-76, 84-107, 113-122</p>
<p>----------------------------------------------------------------</p>
<p>TOTAL                               1692   1114    34%</p>
<p>Coverage HTML written to dir ./src/tests/target/reports</p>
<p></p>
<p>=========================== short test summary info ============================</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_getPosts_NoContent - Asserti...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_getPostById_BadRequest - Ass...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_getPostById_NotFound - Asser...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_getPostByCreator_NotFound - ...</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_getRoutines_NoContent - A...</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_getRoutineById_BadRequest</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_getRoutineById_NotFound</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_getRoutineByCreator_NotFound</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_getUsersTO_NoContent - Ass...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTOById_BadRequest</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTOById_NotFound - A...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTOByUsername_NotFound</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExercisesTO_NoContent</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_BadRequest</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_NotFound</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_NotFound</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_NoContent</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTOByName_NotFound</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_addExerciseTO_NotFoundUserTO</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_addExerciseTO_Created</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_addExerciseTO_Conflict</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTO_Ok - fas...</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_Ok</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_Ok</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTOByName_Ok</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_BadRequest</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_NotFound</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_Conflict</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_Ok - ...</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_BadRequest</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_NotFound</p>
<p>FAILED ❌  src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_Ok - ...</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTO_NoContent</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutineTOById_BadRequest</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutineTOById_NotFound</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_NotFound</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_NoContent</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTOByName_NotFound</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_addRoutineTO_NotFoundUserTO</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_addRoutineTO_Created - ...</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutineTO_Ok - fasta...</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutineTOById_Ok - f...</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_Ok</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTOByName_Ok</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_BadRequestRoutineId</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_BadRequestExerciseId</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_NotFoundRoutineId</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_NotFoundExerciseId</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_Ok</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_Conflict</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_updateRoutineTO_BadRequest</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_updateRoutineTO_NotFound</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_updateRoutineTO_Ok - fa...</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_BadRequest</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_NotFound</p>
<p>FAILED ❌  src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_Ok - fa...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTO_Ok - fastapi.exc...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTOById_Ok - fastapi...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTOByUsername_Ok - f...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_updateUserTO_BadRequest - ...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_updateUserTO_NotFound - As...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_updateUserTO_Conflict - As...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_updateUserTO_Ok - fastapi....</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_deleteUserTO_BadRequest - ...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_deleteUserTO_NotFound - As...</p>
<p>FAILED ❌  src/tests/routers/usersTO_test.py::test_deleteUserTO_Ok - fastapi....</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_addUser_Created - fastapi.ex...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_getPostByCreator_NoContent</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_addPost_NotFound - Assertion...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_addPost_Created - fastapi.ex...</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getComments_NoContent - A...</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getCommentById_BadRequest</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getCommentById_NotFound</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getCommentsByCreator_NotFound</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getCommentsByCreator_NoContent</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getPostComments_BadRequest</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getPostComments_NotFound</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getPostComments_NoContent</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_addCommentToPost_PostIdBadRequest</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_addCommentToPost_PostNotFound</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_addCommentToPost_UserNotFound</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_addCommentToPost_Ok - Nam...</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getComments_Ok - fastapi....</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getCommentById_Ok - fasta...</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getCommentsByCreator_Ok</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_getPostComments_Ok - fast...</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_udpateCommentFromPost_BadRequest</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_udpateCommentFromPost_CommentNotFound</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_udpateCommentFromPost_PostNotFound</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_udpateCommentFromPost_UserNotFound</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_udpateCommentFromPost_Ok</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_deleteCommentFromPost_BadRequest</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_deleteCommentFromPost_CommentNotFound</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_deleteCommentFromPost_Ok</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_deleteAllPostComments_BadRequest</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_deleteAllPostComments_NotFound</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_deleteAllPostComments_Ok</p>
<p>FAILED ❌  src/tests/routers/comments_test.py::test_deleteAllPostComments_NoContent</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_getPosts_Ok - fastapi.except...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_getPostById_Ok - NameError: ...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_getPostsByCreator_Ok - fasta...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_updatePost_BadRequest - Asse...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_updatePost_NotFound - Assert...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_updatePost_NoContent - NameE...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_updatePost_User_NotFound - N...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_updatePost_Created - NameErr...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_deletePost_BadRequest - Asse...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_deletePost_NotFound - Assert...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_deletePost_Ok - NameError: n...</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_deleteAllCreatorPosts_NotFound</p>
<p>FAILED ❌  src/tests/routers/posts_test.py::test_deleteAllCreatorPosts_Ok - f...</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_getRoutineByCreator_NoContent</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_addRoutine_NotFound - Ass...</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_addRoutine_Created - fast...</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_getRoutines_Ok - fastapi....</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_getRoutineById_Ok - NameE...</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_getRoutinesByCreator_Ok</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_updateRoutine_BadRequest</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_updateRoutine_NotFound - ...</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_updateRoutine_NoContent</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_updateRoutine_UserNotFound</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_updateRoutine_Created - N...</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_deleteRoutine_BadRequest</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_deleteRoutine_NotFound - ...</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_deleteRoutine_Ok - NameEr...</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_deleteAllCreatorRoutines_NotFound</p>
<p>FAILED ❌  src/tests/routers/routines_test.py::test_deleteAllCreatorRoutines_Ok</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getPublicUsers_BadRequest - ...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getPublicUsers_All_Ok - fast...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getPublicUsers_ById_Ok - fas...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getPublicUsers_ByUsername_Ok</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_followUser_Ok - fastapi.exce...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_followUser_NoContent - Asser...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_unfollowUser_Ok - fastapi.ex...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_unfollowUser_NoContent - Ass...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getUsers_Ok - fastapi.except...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getUserById_Ok - NameError: ...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getUserById_BadRequest - Ass...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getUserById_NotFound - Asser...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getUserByUsername_Ok - fasta...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_updateUser_NoContent - NameE...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_updateUser_Ok - NameError: n...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getUserByUsername_NotFound</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_updateUser_BadRequest - Asse...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_updateUser_NotFound - Assert...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_updateUser_Conflict - NameEr...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_deleteUser_Ok - fastapi.exce...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_deleteUser_BadRequest - Asse...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_deleteUser_NotFound - Assert...</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_deleteAllUsers_Ok - fastapi....</p>
<p>FAILED ❌  src/tests/routers/users_test.py::test_getUsers_NoContent - Asserti...</p>
<p>======================== 151 failed, 3 passed in 6.53s =========================</p>
<p></p>
</body>
</html>