============================= test session starts ==============================
platform darwin -- Python 3.11.6, pytest-7.4.2, pluggy-1.3.0 -- /Users/eduardfer/Desktop/TFG TELEMÀTICA/eGym-server/dev-env/bin/python3.11
cachedir: .pytest_cache
rootdir: /Users/eduardfer/Desktop/TFG TELEMÀTICA/eGym-server
configfile: pyproject.toml
plugins: emoji-0.2.0, order-1.1.0, cov-4.1.0, asyncio-0.21.1, anyio-3.7.1, xdist-3.3.1
asyncio: mode=Mode.AUTO
collecting ... collected 154 items

src/tests/routers/posts_test.py::test_getPosts_NoContent FAILED ❌       [  0%]
src/tests/routers/posts_test.py::test_getPostById_BadRequest FAILED ❌   [  1%]
src/tests/routers/posts_test.py::test_getPostById_NotFound FAILED ❌     [  1%]
src/tests/routers/posts_test.py::test_getPostByCreator_NotFound FAILED ❌  [  2%]
src/tests/routers/routines_test.py::test_getRoutines_NoContent FAILED ❌  [  3%]
src/tests/routers/routines_test.py::test_getRoutineById_BadRequest FAILED ❌  [  3%]
src/tests/routers/routines_test.py::test_getRoutineById_NotFound FAILED ❌  [  4%]
src/tests/routers/routines_test.py::test_getRoutineByCreator_NotFound FAILED ❌  [  5%]
src/tests/routers/usersTO_test.py::test_getUsersTO_NoContent FAILED ❌   [  5%]
src/tests/routers/usersTO_test.py::test_getUserTOById_BadRequest FAILED ❌  [  6%]
src/tests/routers/usersTO_test.py::test_getUserTOById_NotFound FAILED ❌  [  7%]
src/tests/routers/usersTO_test.py::test_getUserTOByUsername_NotFound FAILED ❌  [  7%]
src/tests/routers/usersTO_test.py::test_addUserTO_Created PASSED ✅      [  8%]
src/tests/routers/exercisesTO_test.py::test_getExercisesTO_NoContent FAILED ❌  [  9%]
src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_BadRequest FAILED ❌  [  9%]
src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_NotFound FAILED ❌  [ 10%]
src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_NotFound FAILED ❌  [ 11%]
src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_NoContent FAILED ❌  [ 11%]
src/tests/routers/exercisesTO_test.py::test_getExerciseTOByName_NotFound FAILED ❌  [ 12%]
src/tests/routers/exercisesTO_test.py::test_addExerciseTO_NotFoundUserTO FAILED ❌  [ 12%]
src/tests/routers/exercisesTO_test.py::test_addExerciseTO_Created FAILED ❌  [ 13%]
src/tests/routers/exercisesTO_test.py::test_addExerciseTO_Conflict FAILED ❌  [ 14%]
src/tests/routers/exercisesTO_test.py::test_getExerciseTO_Ok FAILED ❌   [ 14%]
src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_Ok FAILED ❌  [ 15%]
src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_Ok FAILED ❌  [ 16%]
src/tests/routers/exercisesTO_test.py::test_getExerciseTOByName_Ok FAILED ❌  [ 16%]
src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_BadRequest FAILED ❌  [ 17%]
src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_NotFound FAILED ❌  [ 18%]
src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_Conflict FAILED ❌  [ 18%]
src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_Ok FAILED ❌  [ 19%]
src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_BadRequest FAILED ❌  [ 20%]
src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_NotFound FAILED ❌  [ 20%]
src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_Ok FAILED ❌  [ 21%]
src/tests/routers/routinesTO_test.py::test_getRoutinesTO_NoContent FAILED ❌  [ 22%]
src/tests/routers/routinesTO_test.py::test_getRoutineTOById_BadRequest FAILED ❌  [ 22%]
src/tests/routers/routinesTO_test.py::test_getRoutineTOById_NotFound FAILED ❌  [ 23%]
src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_NotFound FAILED ❌  [ 24%]
src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_NoContent FAILED ❌  [ 24%]
src/tests/routers/routinesTO_test.py::test_getRoutinesTOByName_NotFound FAILED ❌  [ 25%]
src/tests/routers/routinesTO_test.py::test_addRoutineTO_NotFoundUserTO FAILED ❌  [ 25%]
src/tests/routers/routinesTO_test.py::test_addRoutineTO_Created FAILED ❌  [ 26%]
src/tests/routers/routinesTO_test.py::test_getRoutineTO_Ok FAILED ❌     [ 27%]
src/tests/routers/routinesTO_test.py::test_getRoutineTOById_Ok FAILED ❌  [ 27%]
src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_Ok FAILED ❌  [ 28%]
src/tests/routers/routinesTO_test.py::test_getRoutinesTOByName_Ok FAILED ❌  [ 29%]
src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_BadRequestRoutineId FAILED ❌  [ 29%]
src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_BadRequestExerciseId FAILED ❌  [ 30%]
src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_NotFoundRoutineId FAILED ❌  [ 31%]
src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_NotFoundExerciseId FAILED ❌  [ 31%]
src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_Ok FAILED ❌  [ 32%]
src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_Conflict FAILED ❌  [ 33%]
src/tests/routers/routinesTO_test.py::test_updateRoutineTO_BadRequest FAILED ❌  [ 33%]
src/tests/routers/routinesTO_test.py::test_updateRoutineTO_NotFound FAILED ❌  [ 34%]
src/tests/routers/routinesTO_test.py::test_updateRoutineTO_Ok FAILED ❌  [ 35%]
src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_BadRequest FAILED ❌  [ 35%]
src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_NotFound FAILED ❌  [ 36%]
src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_Ok FAILED ❌  [ 37%]
src/tests/routers/usersTO_test.py::test_addUserTO_Conflict PASSED ✅     [ 37%]
src/tests/routers/usersTO_test.py::test_getUserTO_Ok FAILED ❌           [ 38%]
src/tests/routers/usersTO_test.py::test_getUserTOById_Ok FAILED ❌       [ 38%]
src/tests/routers/usersTO_test.py::test_getUserTOByUsername_Ok FAILED ❌  [ 39%]
src/tests/routers/usersTO_test.py::test_updateUserTO_BadRequest FAILED ❌  [ 40%]
src/tests/routers/usersTO_test.py::test_updateUserTO_NotFound FAILED ❌  [ 40%]
src/tests/routers/usersTO_test.py::test_updateUserTO_Conflict FAILED ❌  [ 41%]
src/tests/routers/usersTO_test.py::test_updateUserTO_Ok FAILED ❌        [ 42%]
src/tests/routers/usersTO_test.py::test_deleteUserTO_BadRequest FAILED ❌  [ 42%]
src/tests/routers/usersTO_test.py::test_deleteUserTO_NotFound FAILED ❌  [ 43%]
src/tests/routers/usersTO_test.py::test_deleteUserTO_Ok FAILED ❌        [ 44%]
src/tests/routers/users_test.py::test_addUser_Created FAILED ❌          [ 44%]
src/tests/routers/posts_test.py::test_getPostByCreator_NoContent FAILED ❌  [ 45%]
src/tests/routers/posts_test.py::test_addPost_NotFound FAILED ❌         [ 46%]
src/tests/routers/posts_test.py::test_addPost_Created FAILED ❌          [ 46%]
src/tests/routers/comments_test.py::test_getComments_NoContent FAILED ❌  [ 47%]
src/tests/routers/comments_test.py::test_getCommentById_BadRequest FAILED ❌  [ 48%]
src/tests/routers/comments_test.py::test_getCommentById_NotFound FAILED ❌  [ 48%]
src/tests/routers/comments_test.py::test_getCommentsByCreator_NotFound FAILED ❌  [ 49%]
src/tests/routers/comments_test.py::test_getCommentsByCreator_NoContent FAILED ❌  [ 50%]
src/tests/routers/comments_test.py::test_getPostComments_BadRequest FAILED ❌  [ 50%]
src/tests/routers/comments_test.py::test_getPostComments_NotFound FAILED ❌  [ 51%]
src/tests/routers/comments_test.py::test_getPostComments_NoContent FAILED ❌  [ 51%]
src/tests/routers/comments_test.py::test_addCommentToPost_PostIdBadRequest FAILED ❌  [ 52%]
src/tests/routers/comments_test.py::test_addCommentToPost_PostNotFound FAILED ❌  [ 53%]
src/tests/routers/comments_test.py::test_addCommentToPost_UserNotFound FAILED ❌  [ 53%]
src/tests/routers/comments_test.py::test_addCommentToPost_Ok FAILED ❌   [ 54%]
src/tests/routers/comments_test.py::test_getComments_Ok FAILED ❌        [ 55%]
src/tests/routers/comments_test.py::test_getCommentById_Ok FAILED ❌     [ 55%]
src/tests/routers/comments_test.py::test_getCommentsByCreator_Ok FAILED ❌  [ 56%]
src/tests/routers/comments_test.py::test_getPostComments_Ok FAILED ❌    [ 57%]
src/tests/routers/comments_test.py::test_udpateCommentFromPost_BadRequest FAILED ❌  [ 57%]
src/tests/routers/comments_test.py::test_udpateCommentFromPost_CommentNotFound FAILED ❌  [ 58%]
src/tests/routers/comments_test.py::test_udpateCommentFromPost_PostNotFound FAILED ❌  [ 59%]
src/tests/routers/comments_test.py::test_udpateCommentFromPost_UserNotFound FAILED ❌  [ 59%]
src/tests/routers/comments_test.py::test_udpateCommentFromPost_Ok FAILED ❌  [ 60%]
src/tests/routers/comments_test.py::test_deleteCommentFromPost_BadRequest FAILED ❌  [ 61%]
src/tests/routers/comments_test.py::test_deleteCommentFromPost_CommentNotFound FAILED ❌  [ 61%]
src/tests/routers/comments_test.py::test_deleteCommentFromPost_Ok FAILED ❌  [ 62%]
src/tests/routers/comments_test.py::test_deleteAllPostComments_BadRequest FAILED ❌  [ 62%]
src/tests/routers/comments_test.py::test_deleteAllPostComments_NotFound FAILED ❌  [ 63%]
src/tests/routers/comments_test.py::test_deleteAllPostComments_Ok FAILED ❌  [ 64%]
src/tests/routers/comments_test.py::test_deleteAllPostComments_NoContent FAILED ❌  [ 64%]
src/tests/routers/posts_test.py::test_getPosts_Ok FAILED ❌              [ 65%]
src/tests/routers/posts_test.py::test_getPostById_Ok FAILED ❌           [ 66%]
src/tests/routers/posts_test.py::test_getPostsByCreator_Ok FAILED ❌     [ 66%]
src/tests/routers/posts_test.py::test_updatePost_BadRequest FAILED ❌    [ 67%]
src/tests/routers/posts_test.py::test_updatePost_NotFound FAILED ❌      [ 68%]
src/tests/routers/posts_test.py::test_updatePost_NoContent FAILED ❌     [ 68%]
src/tests/routers/posts_test.py::test_updatePost_User_NotFound FAILED ❌  [ 69%]
src/tests/routers/posts_test.py::test_updatePost_Created FAILED ❌       [ 70%]
src/tests/routers/posts_test.py::test_deletePost_BadRequest FAILED ❌    [ 70%]
src/tests/routers/posts_test.py::test_deletePost_NotFound FAILED ❌      [ 71%]
src/tests/routers/posts_test.py::test_deletePost_Ok FAILED ❌            [ 72%]
src/tests/routers/posts_test.py::test_deleteAllCreatorPosts_NotFound FAILED ❌  [ 72%]
src/tests/routers/posts_test.py::test_deleteAllCreatorPosts_Ok FAILED ❌  [ 73%]
src/tests/routers/routines_test.py::test_getRoutineByCreator_NoContent FAILED ❌  [ 74%]
src/tests/routers/routines_test.py::test_addRoutine_NotFound FAILED ❌   [ 74%]
src/tests/routers/routines_test.py::test_addRoutine_Created FAILED ❌    [ 75%]
src/tests/routers/routines_test.py::test_getRoutines_Ok FAILED ❌        [ 75%]
src/tests/routers/routines_test.py::test_getRoutineById_Ok FAILED ❌     [ 76%]
src/tests/routers/routines_test.py::test_getRoutinesByCreator_Ok FAILED ❌  [ 77%]
src/tests/routers/routines_test.py::test_updateRoutine_BadRequest FAILED ❌  [ 77%]
src/tests/routers/routines_test.py::test_updateRoutine_NotFound FAILED ❌  [ 78%]
src/tests/routers/routines_test.py::test_updateRoutine_NoContent FAILED ❌  [ 79%]
src/tests/routers/routines_test.py::test_updateRoutine_UserNotFound FAILED ❌  [ 79%]
src/tests/routers/routines_test.py::test_updateRoutine_Created FAILED ❌  [ 80%]
src/tests/routers/routines_test.py::test_deleteRoutine_BadRequest FAILED ❌  [ 81%]
src/tests/routers/routines_test.py::test_deleteRoutine_NotFound FAILED ❌  [ 81%]
src/tests/routers/routines_test.py::test_deleteRoutine_Ok FAILED ❌      [ 82%]
src/tests/routers/routines_test.py::test_deleteAllCreatorRoutines_NotFound FAILED ❌  [ 83%]
src/tests/routers/routines_test.py::test_deleteAllCreatorRoutines_Ok FAILED ❌  [ 83%]
src/tests/routers/users_test.py::test_getPublicUsers_BadRequest FAILED ❌  [ 84%]
src/tests/routers/users_test.py::test_getPublicUsers_All_Ok FAILED ❌    [ 85%]
src/tests/routers/users_test.py::test_getPublicUsers_ById_Ok FAILED ❌   [ 85%]
src/tests/routers/users_test.py::test_getPublicUsers_ByUsername_Ok FAILED ❌  [ 86%]
src/tests/routers/users_test.py::test_followUser_Ok FAILED ❌            [ 87%]
src/tests/routers/users_test.py::test_followUser_NoContent FAILED ❌     [ 87%]
src/tests/routers/users_test.py::test_unfollowUser_Ok FAILED ❌          [ 88%]
src/tests/routers/users_test.py::test_unfollowUser_NoContent FAILED ❌   [ 88%]
src/tests/routers/users_test.py::test_getUsers_Ok FAILED ❌              [ 89%]
src/tests/routers/users_test.py::test_addUser_Conflict PASSED ✅         [ 90%]
src/tests/routers/users_test.py::test_getUserById_Ok FAILED ❌           [ 90%]
src/tests/routers/users_test.py::test_getUserById_BadRequest FAILED ❌   [ 91%]
src/tests/routers/users_test.py::test_getUserById_NotFound FAILED ❌     [ 92%]
src/tests/routers/users_test.py::test_getUserByUsername_Ok FAILED ❌     [ 92%]
src/tests/routers/users_test.py::test_updateUser_NoContent FAILED ❌     [ 93%]
src/tests/routers/users_test.py::test_updateUser_Ok FAILED ❌            [ 94%]
src/tests/routers/users_test.py::test_getUserByUsername_NotFound FAILED ❌  [ 94%]
src/tests/routers/users_test.py::test_updateUser_BadRequest FAILED ❌    [ 95%]
src/tests/routers/users_test.py::test_updateUser_NotFound FAILED ❌      [ 96%]
src/tests/routers/users_test.py::test_updateUser_Conflict FAILED ❌      [ 96%]
src/tests/routers/users_test.py::test_deleteUser_Ok FAILED ❌            [ 97%]
src/tests/routers/users_test.py::test_deleteUser_BadRequest FAILED ❌    [ 98%]
src/tests/routers/users_test.py::test_deleteUser_NotFound FAILED ❌      [ 98%]
src/tests/routers/users_test.py::test_deleteAllUsers_Ok FAILED ❌        [ 99%]
src/tests/routers/users_test.py::test_getUsers_NoContent FAILED ❌       [100%]

=================================== FAILURES ===================================
___________________________ test_getPosts_NoContent ____________________________

    @pytest.mark.asyncio
    async def test_getPosts_NoContent():
        with pytest.raises(HTTPException) as exception:
            await posts.getPosts()
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/posts_test.py:38: AssertionError
_________________________ test_getPostById_BadRequest __________________________

    @pytest.mark.asyncio
    async def test_getPostById_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await posts.getPostById("id_is_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/posts_test.py:46: AssertionError
__________________________ test_getPostById_NotFound ___________________________

    @pytest.mark.asyncio
    async def test_getPostById_NotFound():
        with pytest.raises(HTTPException) as exception:
            await posts.getPostById(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/posts_test.py:54: AssertionError
________________________ test_getPostByCreator_NotFound ________________________

    @pytest.mark.asyncio
    async def test_getPostByCreator_NotFound():
        with pytest.raises(HTTPException) as exception:
            await posts.getPostsByCreator("eduardferre")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/posts_test.py:62: AssertionError
__________________________ test_getRoutines_NoContent __________________________

    @pytest.mark.asyncio
    async def test_getRoutines_NoContent():
        with pytest.raises(HTTPException) as exception:
            await routines.getRoutines()
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routines_test.py:62: AssertionError
________________________ test_getRoutineById_BadRequest ________________________

    @pytest.mark.asyncio
    async def test_getRoutineById_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await routines.getRoutineById("id_is_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routines_test.py:70: AssertionError
_________________________ test_getRoutineById_NotFound _________________________

    @pytest.mark.asyncio
    async def test_getRoutineById_NotFound():
        with pytest.raises(HTTPException) as exception:
            await routines.getRoutineById(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routines_test.py:78: AssertionError
______________________ test_getRoutineByCreator_NotFound _______________________

    @pytest.mark.asyncio
    async def test_getRoutineByCreator_NotFound():
        with pytest.raises(HTTPException) as exception:
            await routines.getRoutinesByCreator("eduardferre")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routines_test.py:86: AssertionError
__________________________ test_getUsersTO_NoContent ___________________________

    @pytest.mark.asyncio
    async def test_getUsersTO_NoContent():
        with pytest.raises(HTTPException) as exception:
            await usersTO.getUsersTO()
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/usersTO_test.py:39: AssertionError
________________________ test_getUserTOById_BadRequest _________________________

    @pytest.mark.asyncio
    async def test_getUserTOById_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await usersTO.getUserTOById("id_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/usersTO_test.py:47: AssertionError
_________________________ test_getUserTOById_NotFound __________________________

    @pytest.mark.asyncio
    async def test_getUserTOById_NotFound():
        with pytest.raises(HTTPException) as exception:
            await usersTO.getUserTOById(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/usersTO_test.py:55: AssertionError
______________________ test_getUserTOByUsername_NotFound _______________________

    @pytest.mark.asyncio
    async def test_getUserTOByUsername_NotFound():
        with pytest.raises(HTTPException) as exception:
            await usersTO.getUserTOByUsername("eduardferre")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/usersTO_test.py:63: AssertionError
________________________ test_getExercisesTO_NoContent _________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getExercisesTO_NoContent():
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.getExercisesTO()
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:38: AssertionError
______________________ test_getExerciseTOById_BadRequest _______________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getExerciseTOById_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.getExerciseTOById("id_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:47: AssertionError
_______________________ test_getExerciseTOById_NotFound ________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getExerciseTOById_NotFound():
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.getExerciseTOById(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:56: AssertionError
____________________ test_getExercisesTOByCreator_NotFound _____________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getExercisesTOByCreator_NotFound():
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.getExercisesTOByCreator("not_found_user")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:65: AssertionError
____________________ test_getExercisesTOByCreator_NoContent ____________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getExercisesTOByCreator_NoContent():
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.getExercisesTOByCreator("eduardferre")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:74: AssertionError
______________________ test_getExerciseTOByName_NotFound _______________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getExerciseTOByName_NotFound():
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.getExerciseTOByName("not_found")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:83: AssertionError
______________________ test_addExerciseTO_NotFoundUserTO _______________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addExerciseTO_NotFoundUserTO():
        exercise_not_found_user = exerciseTO_add.model_copy()
        exercise_not_found_user.creator = "test21"
    
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.addExerciseTO(exercise_not_found_user)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:95: AssertionError
__________________________ test_addExerciseTO_Created __________________________

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addExerciseTO_Created():
>       exercise_response = await exercisesTO.addExerciseTO(exerciseTO_add)

src/tests/routers/exercisesTO_test.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/exercisesTO.py:150: in addExerciseTO
    if token_validation(token) != None:
src/main/routers/exercisesTO.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_________________________ test_addExerciseTO_Conflict __________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addExerciseTO_Conflict():
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.addExerciseTO(exerciseTO_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 409
E       AssertionError: assert 401 == 409
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:113: AssertionError
____________________________ test_getExerciseTO_Ok _____________________________

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getExerciseTO_Ok():
>       exercises_list = await exercisesTO.getExercisesTO()

src/tests/routers/exercisesTO_test.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/exercisesTO.py:36: in getExercisesTO
    if token_validation(token) != None:
src/main/routers/exercisesTO.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
__________________________ test_getExerciseTOById_Ok ___________________________

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getExerciseTOById_Ok():
>       exercise_response = await exercisesTO.getExerciseTOById(exerciseTO_add.id)

src/tests/routers/exercisesTO_test.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/exercisesTO.py:61: in getExerciseTOById
    if token_validation(token) != None:
src/main/routers/exercisesTO.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_______________________ test_getExercisesTOByCreator_Ok ________________________

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getExercisesTOByCreator_Ok():
>       exercises_list = await exercisesTO.getExercisesTOByCreator("eduardferre")

src/tests/routers/exercisesTO_test.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/exercisesTO.py:93: in getExercisesTOByCreator
    if token_validation(token) != None:
src/main/routers/exercisesTO.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_________________________ test_getExerciseTOByName_Ok __________________________

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getExerciseTOByName_Ok():
>       exercise_response = await exercisesTO.getExerciseTOByName("Dead Lift")

src/tests/routers/exercisesTO_test.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/exercisesTO.py:129: in getExerciseTOByName
    if token_validation(token) != None:
src/main/routers/exercisesTO.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_______________________ test_updateExerciseTO_BadRequest _______________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_updateExerciseTO_BadRequest():
        exercise_not_valid_id = exerciseTO_add.model_copy()
        exercise_not_valid_id.id = "not_valid_id"
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.updateExerciseTO(exercise_not_valid_id)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:156: AssertionError
________________________ test_updateExerciseTO_NotFound ________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_updateExerciseTO_NotFound():
        exercise_not_found = exerciseTO_add.model_copy()
        exercise_not_found.id = id_test_404
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.updateExerciseTO(exercise_not_found)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:167: AssertionError
________________________ test_updateExerciseTO_Conflict ________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_updateExerciseTO_Conflict():
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.updateExerciseTO(exerciseTO_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 409
E       AssertionError: assert 401 == 409
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:176: AssertionError
___________________________ test_updateExerciseTO_Ok ___________________________

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_updateExerciseTO_Ok():
        exercise_update = exerciseTO_add.model_copy()
        exercise_update.name = "Squat"
>       exercise_response = await exercisesTO.updateExerciseTO(exercise_update)

src/tests/routers/exercisesTO_test.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/exercisesTO.py:191: in updateExerciseTO
    if token_validation(token) != None:
src/main/routers/exercisesTO.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_______________________ test_deleteExerciseTO_BadRequest _______________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_deleteExerciseTO_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.deleteExerciseTO("not_valid_id")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:196: AssertionError
________________________ test_deleteExerciseTO_NotFound ________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_deleteExerciseTO_NotFound():
        with pytest.raises(HTTPException) as exception:
            await exercisesTO.deleteExerciseTO(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/exercisesTO_test.py:205: AssertionError
___________________________ test_deleteExerciseTO_Ok ___________________________

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_deleteExerciseTO_Ok():
>       exercise_to_delete = await exercisesTO.getExercisesTOByCreator("eduardferre")

src/tests/routers/exercisesTO_test.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/exercisesTO.py:93: in getExercisesTOByCreator
    if token_validation(token) != None:
src/main/routers/exercisesTO.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_________________________ test_getRoutinesTO_NoContent _________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getRoutinesTO_NoContent():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.getRoutinesTO()
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:48: AssertionError
_______________________ test_getRoutineTOById_BadRequest _______________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getRoutineTOById_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.getRoutineTOById("id_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:57: AssertionError
________________________ test_getRoutineTOById_NotFound ________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getRoutineTOById_NotFound():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.getRoutineTOById(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:66: AssertionError
_____________________ test_getRoutinesTOByCreator_NotFound _____________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getRoutinesTOByCreator_NotFound():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.getRoutinesTOByCreator("not_found_user")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:75: AssertionError
____________________ test_getRoutinesTOByCreator_NoContent _____________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getRoutinesTOByCreator_NoContent():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.getRoutinesTOByCreator("eduardferre")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:84: AssertionError
______________________ test_getRoutinesTOByName_NotFound _______________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getRoutinesTOByName_NotFound():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.getRoutinesTOByName("not_found")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:93: AssertionError
_______________________ test_addRoutineTO_NotFoundUserTO _______________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addRoutineTO_NotFoundUserTO():
        routine_not_found_user = routineTO_add.model_copy()
        routine_not_found_user.creator = "test21"
    
        with pytest.raises(HTTPException) as exception:
            await routinesTO.addRoutineTO(routine_not_found_user)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:105: AssertionError
__________________________ test_addRoutineTO_Created ___________________________

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addRoutineTO_Created():
>       routine_response = await routinesTO.addRoutineTO(routineTO_add)

src/tests/routers/routinesTO_test.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routinesTO.py:165: in addRoutineTO
    if token_validation(token) != None:
src/main/routers/routinesTO.py:25: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_____________________________ test_getRoutineTO_Ok _____________________________

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getRoutineTO_Ok():
>       routines_list = await routinesTO.getRoutinesTO()

src/tests/routers/routinesTO_test.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routinesTO.py:37: in getRoutinesTO
    if token_validation(token) != None:
src/main/routers/routinesTO.py:25: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
___________________________ test_getRoutineTOById_Ok ___________________________

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getRoutineTOById_Ok():
>       routine_response = await routinesTO.getRoutineTOById(routineTO_add.id)

src/tests/routers/routinesTO_test.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routinesTO.py:66: in getRoutineTOById
    if token_validation(token) != None:
src/main/routers/routinesTO.py:25: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
________________________ test_getRoutinesTOByCreator_Ok ________________________

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getRoutinesTOByCreator_Ok():
>       routines_list = await routinesTO.getRoutinesTOByCreator("eduardferre")

src/tests/routers/routinesTO_test.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routinesTO.py:97: in getRoutinesTOByCreator
    if token_validation(token) != None:
src/main/routers/routinesTO.py:25: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_________________________ test_getRoutinesTOByName_Ok __________________________

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_getRoutinesTOByName_Ok():
>       routines_list = await routinesTO.getRoutinesTOByName("LegDay")

src/tests/routers/routinesTO_test.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routinesTO.py:137: in getRoutinesTOByName
    if token_validation(token) != None:
src/main/routers/routinesTO.py:25: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
______________ test_addExerciseTOToRoutineTO_BadRequestRoutineId _______________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addExerciseTOToRoutineTO_BadRequestRoutineId():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.addExerciseTOToRoutineTO("id_not_valid", "id_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:155: AssertionError
______________ test_addExerciseTOToRoutineTO_BadRequestExerciseId ______________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addExerciseTOToRoutineTO_BadRequestExerciseId():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.addExerciseTOToRoutineTO(id_test_404, "id_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:164: AssertionError
_______________ test_addExerciseTOToRoutineTO_NotFoundRoutineId ________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addExerciseTOToRoutineTO_NotFoundRoutineId():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.addExerciseTOToRoutineTO(id_test_404, id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:173: AssertionError
_______________ test_addExerciseTOToRoutineTO_NotFoundExerciseId _______________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addExerciseTOToRoutineTO_NotFoundExerciseId():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.addExerciseTOToRoutineTO(routineTO_add.id, id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:182: AssertionError
_______________________ test_addExerciseTOToRoutineTO_Ok _______________________

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addExerciseTOToRoutineTO_Ok():
>       exercise_response = await exercisesTO.addExerciseTO(exerciseTO_add)

src/tests/routers/routinesTO_test.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/exercisesTO.py:150: in addExerciseTO
    if token_validation(token) != None:
src/main/routers/exercisesTO.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107985990>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
____________________ test_addExerciseTOToRoutineTO_Conflict ____________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_addExerciseTOToRoutineTO_Conflict():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.addExerciseTOToRoutineTO(routineTO_add.id, exerciseTO_add.id)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 409
E       AssertionError: assert 401 == 409
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:205: AssertionError
_______________________ test_updateRoutineTO_BadRequest ________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_updateRoutineTO_BadRequest():
        routine_not_valid_id = routineTO_add.model_copy()
        routine_not_valid_id.id = "not_valid_id"
        with pytest.raises(HTTPException) as exception:
            await routinesTO.updateRoutineTO(routine_not_valid_id)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:216: AssertionError
________________________ test_updateRoutineTO_NotFound _________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_updateRoutineTO_NotFound():
        routine_not_found = routineTO_add.model_copy()
        routine_not_found.id = id_test_404
        with pytest.raises(HTTPException) as exception:
            await routinesTO.updateRoutineTO(routine_not_found)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:227: AssertionError
___________________________ test_updateRoutineTO_Ok ____________________________

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_updateRoutineTO_Ok():
        routine_update = routineTO_add.model_copy()
        routine_update.description = "eduardfer"
>       routine_response = await routinesTO.updateRoutineTO(routine_update)

src/tests/routers/routinesTO_test.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routinesTO.py:266: in updateRoutineTO
    if token_validation(token) != None:
src/main/routers/routinesTO.py:25: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_______________________ test_deleteRoutineTO_BadRequest ________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_deleteRoutineTO_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.deleteRoutineTO("not_valid_id")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:247: AssertionError
________________________ test_deleteRoutineTO_NotFound _________________________

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_deleteRoutineTO_NotFound():
        with pytest.raises(HTTPException) as exception:
            await routinesTO.deleteRoutineTO(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routinesTO_test.py:256: AssertionError
___________________________ test_deleteRoutineTO_Ok ____________________________

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="usersTO_test.py::test_addUserTO_Created")
    @pytest.mark.asyncio
    async def test_deleteRoutineTO_Ok():
>       routine_to_delete = await routinesTO.getRoutinesTOByCreator("eduardferre")

src/tests/routers/routinesTO_test.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routinesTO.py:97: in getRoutinesTOByCreator
    if token_validation(token) != None:
src/main/routers/routinesTO.py:25: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x10799ca10>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
______________________________ test_getUserTO_Ok _______________________________

self = <src.main.services.auth.Auth object at 0x1047c2a50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_getUserTO_Ok():
>       users_list = await usersTO.getUsersTO()

src/tests/routers/usersTO_test.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/usersTO.py:39: in getUsersTO
    if token_validation(token) != None:
src/main/routers/usersTO.py:27: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1047c2a50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
____________________________ test_getUserTOById_Ok _____________________________

self = <src.main.services.auth.Auth object at 0x1047c2a50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_getUserTOById_Ok():
>       user_response = await usersTO.getUserTOById(userTO_add.id)

src/tests/routers/usersTO_test.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/usersTO.py:67: in getUserTOById
    if token_validation(token) != None:
src/main/routers/usersTO.py:27: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1047c2a50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_________________________ test_getUserTOByUsername_Ok __________________________

self = <src.main.services.auth.Auth object at 0x1047c2a50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_getUserTOByUsername_Ok():
>       user_response = await usersTO.getUserTOByUsername("eduardferre")

src/tests/routers/usersTO_test.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/usersTO.py:118: in getUserTOByUsername
    if token_validation(token) != None:
src/main/routers/usersTO.py:27: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1047c2a50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_________________________ test_updateUserTO_BadRequest _________________________

    @pytest.mark.asyncio
    async def test_updateUserTO_BadRequest():
        user_not_valid_id = userTO_add.model_copy()
        user_not_valid_id.id = "not_valid_id"
        with pytest.raises(HTTPException) as exception:
            await usersTO.updateUserTO(user_not_valid_id)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/usersTO_test.py:114: AssertionError
__________________________ test_updateUserTO_NotFound __________________________

    @pytest.mark.asyncio
    async def test_updateUserTO_NotFound():
        user_not_found = userTO_add.model_copy()
        user_not_found.id = id_test_404
        with pytest.raises(HTTPException) as exception:
            await usersTO.updateUserTO(user_not_found)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/usersTO_test.py:124: AssertionError
__________________________ test_updateUserTO_Conflict __________________________

    @pytest.mark.asyncio
    async def test_updateUserTO_Conflict():
        user_not_found = userTO_add.model_copy()
        user_not_found.username = "test2"
        with pytest.raises(HTTPException) as exception:
            await usersTO.updateUserTO(user_not_found)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 409
E       AssertionError: assert 401 == 409
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/usersTO_test.py:134: AssertionError
_____________________________ test_updateUserTO_Ok _____________________________

self = <src.main.services.auth.Auth object at 0x1047c2a50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_updateUserTO_Ok():
        user_update = userTO_add.model_copy()
        user_update.username = "eduardfer"
>       user_response = await usersTO.updateUserTO(user_update)

src/tests/routers/usersTO_test.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/usersTO.py:164: in updateUserTO
    if token_validation(token) != None:
src/main/routers/usersTO.py:27: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1047c2a50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_________________________ test_deleteUserTO_BadRequest _________________________

    @pytest.mark.asyncio
    async def test_deleteUserTO_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await usersTO.deleteUserTO("not_valid_id")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/usersTO_test.py:152: AssertionError
__________________________ test_deleteUserTO_NotFound __________________________

    @pytest.mark.asyncio
    async def test_deleteUserTO_NotFound():
        with pytest.raises(HTTPException) as exception:
            await usersTO.deleteUserTO(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/usersTO_test.py:160: AssertionError
_____________________________ test_deleteUserTO_Ok _____________________________

self = <src.main.services.auth.Auth object at 0x1047c2a50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_deleteUserTO_Ok():
>       user_to_delete = await usersTO.getUserTOByUsername("eduardfer")

src/tests/routers/usersTO_test.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/usersTO.py:118: in getUserTOByUsername
    if token_validation(token) != None:
src/main/routers/usersTO.py:27: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1047c2a50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_____________________________ test_addUser_Created _____________________________

    @pytest.mark.asyncio
    async def test_addUser_Created():
>       user_response = await users.addUser(user=user_add)

src/tests/routers/users_test.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user = User(id='507f1f77bcf86cd799439011', username='eduardferre', fullname='Eduard Ferré Sánchez', email='eduardferresanchez..., routinesLog=[], routines=[], profilePicture='https://blablabla', backgroundPicture='https://blablabla', public=False)

    async def addUser(user: User):
        # logging.info("POST /users/")
        user_search = await search_user("username", user.username)
    
        if type(user_search) == User:
            logging.info(f"The username '{user.username}' is already used")
>           raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"The username '{user.username}' is already used",
            )
E           fastapi.exceptions.HTTPException

src/main/routers/users.py:183: HTTPException
----------------------------- Captured stderr call -----------------------------
[34;3mINFO:     2023-11-08 20:20:45,691 || The user with username = eduardferre exists in the database - (users.py:389)[0m
[34;3mINFO:     2023-11-08 20:20:45,691 || The username 'eduardferre' is already used - (users.py:182)[0m
------------------------------ Captured log call -------------------------------
INFO     eGym:users.py:389 The user with username = eduardferre exists in the database
INFO     eGym:users.py:182 The username 'eduardferre' is already used
_______________________ test_getPostByCreator_NoContent ________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_getPostByCreator_NoContent():
        with pytest.raises(HTTPException) as exception:
            await posts.getPostsByCreator("eduardferre")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/posts_test.py:71: AssertionError
____________________________ test_addPost_NotFound _____________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_addPost_NotFound():
        post_add.creator = "not_found"
        with pytest.raises(HTTPException) as exception:
            await posts.addPost(post_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/posts_test.py:81: AssertionError
_____________________________ test_addPost_Created _____________________________

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_addPost_Created():
        post_add.creator = "eduardferre"
>       post_response = await posts.addPost(post_add)

src/tests/routers/posts_test.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/posts.py:97: in addPost
    if token_validation(token) != None:
src/main/routers/posts.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
__________________________ test_getComments_NoContent __________________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getComments_NoContent():
        with pytest.raises(HTTPException) as exception:
            await comments.getComments()
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:31: AssertionError
________________________ test_getCommentById_BadRequest ________________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getCommentById_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await comments.getCommentById("id_is_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:40: AssertionError
_________________________ test_getCommentById_NotFound _________________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getCommentById_NotFound():
        with pytest.raises(HTTPException) as exception:
            await comments.getCommentById(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:49: AssertionError
______________________ test_getCommentsByCreator_NotFound ______________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getCommentsByCreator_NotFound():
        with pytest.raises(HTTPException) as exception:
            await comments.getCommentsByCreator("user_not_found")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:58: AssertionError
_____________________ test_getCommentsByCreator_NoContent ______________________

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getCommentsByCreator_NoContent():
>       comments_list = await comments.getCommentsByCreator("eduardferre")

src/tests/routers/comments_test.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/comments.py:73: in getCommentsByCreator
    if token_validation(token) != None:
src/main/routers/comments.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_______________________ test_getPostComments_BadRequest ________________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getPostComments_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await comments.getPostComments("id_is_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:74: AssertionError
________________________ test_getPostComments_NotFound _________________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getPostComments_NotFound():
        with pytest.raises(HTTPException) as exception:
            await comments.getPostComments(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:83: AssertionError
________________________ test_getPostComments_NoContent ________________________

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getPostComments_NoContent():
        global post_response
>       post_response = await posts.getPostsByCreator("eduardferre")

src/tests/routers/comments_test.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/posts.py:73: in getPostsByCreator
    if token_validation(token) != None:
src/main/routers/posts.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
____________________ test_addCommentToPost_PostIdBadRequest ____________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_addCommentToPost_PostIdBadRequest():
        with pytest.raises(HTTPException) as exception:
            await comments.addCommentToPost("is_not_valid_id", comment_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:103: AssertionError
______________________ test_addCommentToPost_PostNotFound ______________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_addCommentToPost_PostNotFound():
        comment_add.postId = id_test_404
        with pytest.raises(HTTPException) as exception:
            await comments.addCommentToPost(id_test_404, comment_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:119: AssertionError
______________________ test_addCommentToPost_UserNotFound ______________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_addCommentToPost_UserNotFound():
>       comment_add.postId = post_response[0]["id"]
E       NameError: name 'post_response' is not defined

src/tests/routers/comments_test.py:125: NameError
___________________________ test_addCommentToPost_Ok ___________________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_addCommentToPost_Ok():
>       comment_add.postId = post_response[0]["id"]
E       NameError: name 'post_response' is not defined

src/tests/routers/comments_test.py:136: NameError
_____________________________ test_getComments_Ok ______________________________

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getComments_Ok():
>       comments_list = await comments.getComments()

src/tests/routers/comments_test.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/comments.py:35: in getComments
    if token_validation(token) != None:
src/main/routers/comments.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
____________________________ test_getCommentById_Ok ____________________________

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getCommentById_Ok():
>       comment_response = await comments.getCommentById(comment_add.id)

src/tests/routers/comments_test.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/comments.py:50: in getCommentById
    if token_validation(token) != None:
src/main/routers/comments.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_________________________ test_getCommentsByCreator_Ok _________________________

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getCommentsByCreator_Ok():
>       comments_list = await comments.getCommentsByCreator("eduardferre")

src/tests/routers/comments_test.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/comments.py:73: in getCommentsByCreator
    if token_validation(token) != None:
src/main/routers/comments.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
___________________________ test_getPostComments_Ok ____________________________

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_getPostComments_Ok():
>       comments_list = await comments.getPostComments(comment_add.postId)

src/tests/routers/comments_test.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/comments.py:99: in getPostComments
    if token_validation(token) != None:
src/main/routers/comments.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
____________________ test_udpateCommentFromPost_BadRequest _____________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_udpateCommentFromPost_BadRequest():
        comment_400 = comment_add.copy()
    
        with pytest.raises(HTTPException) as exception:
            await comments.updateCommentFromPost("is_not_valid_id", comment_400)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:192: AssertionError
__________________ test_udpateCommentFromPost_CommentNotFound __________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_udpateCommentFromPost_CommentNotFound():
        comment_404 = comment_add.copy()
        comment_404.id = id_test_404
        with pytest.raises(HTTPException) as exception:
            await comments.updateCommentFromPost(comment_404.postId, comment_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:220: AssertionError
___________________ test_udpateCommentFromPost_PostNotFound ____________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_udpateCommentFromPost_PostNotFound():
        comment_404 = comment_add.copy()
        comment_404.postId = id_test_404
        with pytest.raises(HTTPException) as exception:
            await comments.updateCommentFromPost(comment_404.postId, comment_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:231: AssertionError
___________________ test_udpateCommentFromPost_UserNotFound ____________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_udpateCommentFromPost_UserNotFound():
        comment_404 = comment_add.copy()
        comment_404.creator = "user_not_found"
        with pytest.raises(HTTPException) as exception:
            await comments.updateCommentFromPost(comment_404.postId, comment_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:242: AssertionError
________________________ test_udpateCommentFromPost_Ok _________________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_udpateCommentFromPost_Ok():
>       comment_duplicated.content = "This comment has been updated"
E       NameError: name 'comment_duplicated' is not defined

src/tests/routers/comments_test.py:248: NameError
____________________ test_deleteCommentFromPost_BadRequest _____________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_deleteCommentFromPost_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await comments.deleteCommentFromPost("is_not_valid_id", comment_add.id)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:264: AssertionError
__________________ test_deleteCommentFromPost_CommentNotFound __________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_deleteCommentFromPost_CommentNotFound():
        with pytest.raises(HTTPException) as exception:
            await comments.deleteCommentFromPost(comment_add.postId, id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:288: AssertionError
________________________ test_deleteCommentFromPost_Ok _________________________

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_deleteCommentFromPost_Ok():
>       comment_response = await comments.deleteCommentFromPost(
            comment_add.postId, comment_add.id
        )

src/tests/routers/comments_test.py:303: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/comments.py:288: in deleteCommentFromPost
    if token_validation(token) != None:
src/main/routers/comments.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
____________________ test_deleteAllPostComments_BadRequest _____________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_deleteAllPostComments_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await comments.deleteAllPostComments("id_is_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:329: AssertionError
_____________________ test_deleteAllPostComments_NotFound ______________________

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_deleteAllPostComments_NotFound():
        with pytest.raises(HTTPException) as exception:
            await comments.deleteAllPostComments(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/comments_test.py:338: AssertionError
________________________ test_deleteAllPostComments_Ok _________________________

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_deleteAllPostComments_Ok():
>       post_comments_response = await comments.deleteAllPostComments(comment_add.postId)

src/tests/routers/comments_test.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/comments.py:362: in deleteAllPostComments
    if token_validation(token) != None:
src/main/routers/comments.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_____________________ test_deleteAllPostComments_NoContent _____________________

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="posts_test.py::test_addPost_Created")
    @pytest.mark.asyncio
    async def test_deleteAllPostComments_NoContent():
>       post_comments_response = await comments.deleteAllPostComments(comment_add.postId)

src/tests/routers/comments_test.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/comments.py:362: in deleteAllPostComments
    if token_validation(token) != None:
src/main/routers/comments.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107871d50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_______________________________ test_getPosts_Ok _______________________________

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_getPosts_Ok():
>       posts_list = await posts.getPosts()

src/tests/routers/posts_test.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/posts.py:36: in getPosts
    if token_validation(token) != None:
src/main/routers/posts.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_____________________________ test_getPostById_Ok ______________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_getPostById_Ok():
>       post_response = await posts.getPostById(id_test_Ok)
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/posts_test.py:106: NameError
__________________________ test_getPostsByCreator_Ok ___________________________

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_getPostsByCreator_Ok():
>       posts_list = await posts.getPostsByCreator("eduardferre")

src/tests/routers/posts_test.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/posts.py:73: in getPostsByCreator
    if token_validation(token) != None:
src/main/routers/posts.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
__________________________ test_updatePost_BadRequest __________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_updatePost_BadRequest():
        post_add.id = "id_is_not_valid"
        with pytest.raises(HTTPException) as exception:
            await posts.updatePost(post_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/posts_test.py:136: AssertionError
___________________________ test_updatePost_NotFound ___________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_updatePost_NotFound():
        post_add.id = id_test_404
        with pytest.raises(HTTPException) as exception:
            await posts.updatePost(post_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/posts_test.py:146: AssertionError
__________________________ test_updatePost_NoContent ___________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_updatePost_NoContent():
        post_add.creator = "eduardferre"
>       post_add.id = id_test_Ok
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/posts_test.py:153: NameError
________________________ test_updatePost_User_NotFound _________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_updatePost_User_NotFound():
>       post_add.id = id_test_Ok
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/posts_test.py:163: NameError
___________________________ test_updatePost_Created ____________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_updatePost_Created():
        post_add.creator = "eduardferre"
>       post_add.id = id_test_Ok
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/posts_test.py:175: NameError
__________________________ test_deletePost_BadRequest __________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_deletePost_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await posts.deletePost("id_is_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/posts_test.py:187: AssertionError
___________________________ test_deletePost_NotFound ___________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_deletePost_NotFound():
        with pytest.raises(HTTPException) as exception:
            await posts.deletePost(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/posts_test.py:196: AssertionError
______________________________ test_deletePost_Ok ______________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_deletePost_Ok():
>       post_response = await posts.deletePost(id_test_Ok)
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/posts_test.py:202: NameError
_____________________ test_deleteAllCreatorPosts_NotFound ______________________

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_deleteAllCreatorPosts_NotFound():
        post_add.creator = "eduardferre"
>       post_response = await posts.addPost(post_add)

src/tests/routers/posts_test.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/posts.py:97: in addPost
    if token_validation(token) != None:
src/main/routers/posts.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
________________________ test_deleteAllCreatorPosts_Ok _________________________

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_deleteAllCreatorPosts_Ok():
>       posts_list = await posts.deleteAllCreatorPosts("eduardferre")

src/tests/routers/posts_test.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/posts.py:271: in deleteAllCreatorPosts
    if token_validation(token) != None:
src/main/routers/posts.py:24: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x107870e90>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
______________________ test_getRoutineByCreator_NoContent ______________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_getRoutineByCreator_NoContent():
        with pytest.raises(HTTPException) as exception:
            await routines.getRoutinesByCreator("eduardferre")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routines_test.py:95: AssertionError
___________________________ test_addRoutine_NotFound ___________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_addRoutine_NotFound():
        routine_add.creator = "not_found"
        with pytest.raises(HTTPException) as exception:
            await routines.addRoutine(routine_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routines_test.py:105: AssertionError
___________________________ test_addRoutine_Created ____________________________

self = <src.main.services.auth.Auth object at 0x1078bcb50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_addRoutine_Created():
        routine_add.creator = "eduardferre"
>       routine_response = await routines.addRoutine(routine_add)

src/tests/routers/routines_test.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routines.py:96: in addRoutine
    if token_validation(token) != None:
src/main/routers/routines.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1078bcb50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_____________________________ test_getRoutines_Ok ______________________________

self = <src.main.services.auth.Auth object at 0x1078bcb50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_getRoutines_Ok():
>       routines_list = await routines.getRoutines()

src/tests/routers/routines_test.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routines.py:35: in getRoutines
    if token_validation(token) != None:
src/main/routers/routines.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1078bcb50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
____________________________ test_getRoutineById_Ok ____________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_getRoutineById_Ok():
>       routine_response = await routines.getRoutineById(id_test_Ok)
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/routines_test.py:129: NameError
_________________________ test_getRoutinesByCreator_Ok _________________________

self = <src.main.services.auth.Auth object at 0x1078bcb50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_getRoutinesByCreator_Ok():
>       routines_list = await routines.getRoutinesByCreator("eduardferre")

src/tests/routers/routines_test.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routines.py:73: in getRoutinesByCreator
    if token_validation(token) != None:
src/main/routers/routines.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1078bcb50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
________________________ test_updateRoutine_BadRequest _________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_updateRoutine_BadRequest():
        routine_add.id = "id_is_not_valid"
        with pytest.raises(HTTPException) as exception:
            await routines.updateRoutine(routine_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routines_test.py:152: AssertionError
_________________________ test_updateRoutine_NotFound __________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_updateRoutine_NotFound():
        routine_add.id = id_test_404
        with pytest.raises(HTTPException) as exception:
            await routines.updateRoutine(routine_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routines_test.py:162: AssertionError
_________________________ test_updateRoutine_NoContent _________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_updateRoutine_NoContent():
        routine_add.creator = "eduardferre"
>       routine_add.id = id_test_Ok
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/routines_test.py:169: NameError
_______________________ test_updateRoutine_UserNotFound ________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_updateRoutine_UserNotFound():
>       routine_add.id = id_test_Ok
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/routines_test.py:179: NameError
__________________________ test_updateRoutine_Created __________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_updateRoutine_Created():
        routine_add.creator = "eduardferre"
>       routine_add.id = id_test_Ok
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/routines_test.py:191: NameError
________________________ test_deleteRoutine_BadRequest _________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_deleteRoutine_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await routines.deleteRoutine("id_is_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routines_test.py:203: AssertionError
_________________________ test_deleteRoutine_NotFound __________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_deleteRoutine_NotFound():
        with pytest.raises(HTTPException) as exception:
            await routines.deleteRoutine(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/routines_test.py:212: AssertionError
____________________________ test_deleteRoutine_Ok _____________________________

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_deleteRoutine_Ok():
>       routine_response = await routines.deleteRoutine(id_test_Ok)
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/routines_test.py:218: NameError
____________________ test_deleteAllCreatorRoutines_NotFound ____________________

self = <src.main.services.auth.Auth object at 0x1078bcb50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_deleteAllCreatorRoutines_NotFound():
>       routine_response = await routines.addRoutine(routine_to_delete)

src/tests/routers/routines_test.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routines.py:96: in addRoutine
    if token_validation(token) != None:
src/main/routers/routines.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1078bcb50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_______________________ test_deleteAllCreatorRoutines_Ok _______________________

self = <src.main.services.auth.Auth object at 0x1078bcb50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(after="users_test.py::test_addUser_Created")
    @pytest.mark.asyncio
    async def test_deleteAllCreatorRoutines_Ok():
>       routines_list = await routines.deleteAllCreatorRoutines("eduardferre")

src/tests/routers/routines_test.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/routines.py:277: in deleteAllCreatorRoutines
    if token_validation(token) != None:
src/main/routers/routines.py:23: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1078bcb50>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
________________________ test_getPublicUsers_BadRequest ________________________

    @pytest.mark.asyncio
    async def test_getPublicUsers_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await users.getPublicUsers("attribute_not_valid", "any")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:80: AssertionError
__________________________ test_getPublicUsers_All_Ok __________________________

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_getPublicUsers_All_Ok():
>       user_list = await users.getPublicUsers("public", "users")

src/tests/routers/users_test.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/users.py:38: in getPublicUsers
    if token_validation(token) != None:
src/main/routers/users.py:22: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_________________________ test_getPublicUsers_ById_Ok __________________________

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_getPublicUsers_ById_Ok():
>       user_list = await users.getPublicUsers("_id", user_add.id)

src/tests/routers/users_test.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/users.py:38: in getPublicUsers
    if token_validation(token) != None:
src/main/routers/users.py:22: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
______________________ test_getPublicUsers_ByUsername_Ok _______________________

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_getPublicUsers_ByUsername_Ok():
>       user_list = await users.getPublicUsers("username", "eduardferre")

src/tests/routers/users_test.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/users.py:38: in getPublicUsers
    if token_validation(token) != None:
src/main/routers/users.py:22: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
______________________________ test_followUser_Ok ______________________________

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_followUser_Ok():
>       user_add.following = await users.followUser(
            user_add.username, user_update_conflict.username
        )

src/tests/routers/users_test.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/users.py:76: in followUser
    if token_validation(token) != None:
src/main/routers/users.py:22: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
__________________________ test_followUser_NoContent ___________________________

    @pytest.mark.asyncio
    async def test_followUser_NoContent():
        with pytest.raises(HTTPException) as exception:
            await users.followUser(user_add.username, user_update_conflict.username)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:131: AssertionError
_____________________________ test_unfollowUser_Ok _____________________________

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_unfollowUser_Ok():
>       user_add.following = await users.unfollowUser(
            user_add.username, user_update_conflict.username
        )

src/tests/routers/users_test.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/users.py:104: in unfollowUser
    if token_validation(token) != None:
src/main/routers/users.py:22: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_________________________ test_unfollowUser_NoContent __________________________

    @pytest.mark.asyncio
    async def test_unfollowUser_NoContent():
        with pytest.raises(HTTPException) as exception:
            await users.unfollowUser(user_add.username, user_update_conflict.username)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:150: AssertionError
_______________________________ test_getUsers_Ok _______________________________

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_getUsers_Ok():
>       users_list = await users.getUsers()

src/tests/routers/users_test.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/users.py:126: in getUsers
    if token_validation(token) != None:
src/main/routers/users.py:22: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
_____________________________ test_getUserById_Ok ______________________________

    @pytest.mark.asyncio
    async def test_getUserById_Ok():
>       user_response = await users.getUserById(id_test_Ok)
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/users_test.py:170: NameError
_________________________ test_getUserById_BadRequest __________________________

    @pytest.mark.asyncio
    async def test_getUserById_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await users.getUserById("id_test_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:179: AssertionError
__________________________ test_getUserById_NotFound ___________________________

    @pytest.mark.asyncio
    async def test_getUserById_NotFound():
        with pytest.raises(HTTPException) as exception:
            await users.getUserById(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:187: AssertionError
__________________________ test_getUserByUsername_Ok ___________________________

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_getUserByUsername_Ok():
>       user_search = await users.getUserByUsername("eduardferre")

src/tests/routers/users_test.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/users.py:163: in getUserByUsername
    if token_validation(token) != None:
src/main/routers/users.py:22: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
__________________________ test_updateUser_NoContent ___________________________

    @pytest.mark.asyncio
    async def test_updateUser_NoContent():
>       user_add.id = id_test_Ok
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/users_test.py:198: NameError
______________________________ test_updateUser_Ok ______________________________

    @pytest.mark.asyncio
    async def test_updateUser_Ok():
        user_add.username = "eduardfer"
>       user_add.id = id_test_Ok
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/users_test.py:209: NameError
_______________________ test_getUserByUsername_NotFound ________________________

    @pytest.mark.asyncio
    async def test_getUserByUsername_NotFound():
        with pytest.raises(HTTPException) as exception:
            await users.getUserByUsername("eduardferre")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:220: AssertionError
__________________________ test_updateUser_BadRequest __________________________

    @pytest.mark.asyncio
    async def test_updateUser_BadRequest():
        user_add.id = "id_test_not_valid"
        with pytest.raises(HTTPException) as exception:
            await users.updateUser(user_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:229: AssertionError
___________________________ test_updateUser_NotFound ___________________________

    @pytest.mark.asyncio
    async def test_updateUser_NotFound():
        user_add.id = id_test_404
        with pytest.raises(HTTPException) as exception:
            await users.updateUser(user_add)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:238: AssertionError
___________________________ test_updateUser_Conflict ___________________________

    @pytest.mark.asyncio
    async def test_updateUser_Conflict():
        user_add.username = "aleixferre"
>       user_add.id = id_test_Ok
E       NameError: name 'id_test_Ok' is not defined

src/tests/routers/users_test.py:244: NameError
______________________________ test_deleteUser_Ok ______________________________

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_deleteUser_Ok():
>       user_search = await users.getUserByUsername("eduardfer")

src/tests/routers/users_test.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/users.py:163: in getUserByUsername
    if token_validation(token) != None:
src/main/routers/users.py:22: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
__________________________ test_deleteUser_BadRequest __________________________

    @pytest.mark.asyncio
    async def test_deleteUser_BadRequest():
        with pytest.raises(HTTPException) as exception:
            await users.deleteUser("id_test_not_valid")
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 400
E       AssertionError: assert 401 == 400
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:265: AssertionError
___________________________ test_deleteUser_NotFound ___________________________

    @pytest.mark.asyncio
    async def test_deleteUser_NotFound():
        with pytest.raises(HTTPException) as exception:
            await users.deleteUser(id_test_404)
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 404
E       AssertionError: assert 401 == 404
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:273: AssertionError
____________________________ test_deleteAllUsers_Ok ____________________________

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
>           decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))

src/main/services/auth.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
dev-env/lib/python3.11/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x10608f850>
jwt = Depends(OAuth2PasswordBearer)

    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
>           raise DecodeError(f"Invalid token type. Token must be a {bytes}")
E           jwt.exceptions.DecodeError: Invalid token type. Token must be a <class 'bytes'>

dev-env/lib/python3.11/site-packages/jwt/api_jws.py:254: DecodeError

During handling of the above exception, another exception occurred:

    @pytest.mark.order(before="test_getUsers_NoContent")
    @pytest.mark.asyncio
    async def test_deleteAllUsers_Ok():
>       user_response = await users.deleteAllUsers()

src/tests/routers/users_test.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/main/routers/users.py:371: in deleteAllUsers
    if token_validation(token) != None:
src/main/routers/users.py:22: in token_validation
    return auth_handler.decode_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.main.services.auth.Auth object at 0x1064da9d0>
token = Depends(OAuth2PasswordBearer)

    def decode_token(self, token):
        try:
            pub_key = load_ES256_from_jwk_env().public_key()
            decoded = jwt.decode(token, pub_key, algorithms=os.getenv("JWT_ALGORITHM"))
            return decoded
        except jwt.ExpiredSignatureError:
            logging.info("The token has expired")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token has expired"
            )
        except jwt.InvalidTokenError:
            logging.info("The token is invalid")
>           raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, detail="The token is invalid"
            )
E           fastapi.exceptions.HTTPException

src/main/services/auth.py:63: HTTPException
___________________________ test_getUsers_NoContent ____________________________

    @pytest.mark.order("last")
    @pytest.mark.asyncio
    async def test_getUsers_NoContent():
        with pytest.raises(HTTPException) as exception:
            await users.getUsers()
        assert isinstance(exception.value, HTTPException)
>       assert exception.value.status_code == 204
E       AssertionError: assert 401 == 204
E        +  where 401 = HTTPException(status_code=401, detail='The token is invalid').status_code
E        +    where HTTPException(status_code=401, detail='The token is invalid') = <ExceptionInfo HTTPException(status_code=401, detail='The token is invalid') tblen=4>.value

src/tests/routers/users_test.py:289: AssertionError

---------- coverage: platform darwin, python 3.11.6-final-0 ----------
Name                               Stmts   Miss  Cover   Missing
----------------------------------------------------------------
db/mongodb/client.py                  12      2    83%   12-13
db/mongodb/models/comment.py           8      0   100%
db/mongodb/models/exercise.py         12      0   100%
db/mongodb/models/post.py             18      3    83%   17-27
db/mongodb/models/routine.py          18      3    83%   17-26
db/mongodb/models/set.py               9      0   100%
db/mongodb/models/user.py             26      0   100%
db/mongodb/schemas/comment.py          4      2    50%   2, 11
db/mongodb/schemas/exercise.py         8      5    38%   5-9, 20
db/mongodb/schemas/post.py             4      2    50%   2, 14
db/mongodb/schemas/routine.py          8      4    50%   5-9
db/mongodb/schemas/set.py              7      5    29%   2-6, 17
db/mongodb/schemas/user.py             5      1    80%   28
db/sqlDB/client.py                     7      1    86%   7
db/sqlDB/models/exerciseTO.py          7      0   100%
db/sqlDB/models/routineTO.py           9      0   100%
db/sqlDB/models/userTO.py             10      0   100%
db/sqlDB/schemas/exerciseTO.py         4      2    50%   2, 10
db/sqlDB/schemas/routineTO.py          4      2    50%   2, 11
db/sqlDB/schemas/userTO.py             4      1    75%   13
src/main/__init__.py                   0      0   100%
src/main/main.py                      24      1    96%   41
src/main/models/user_register.py      24      0   100%
src/main/routers/__init__.py           0      0   100%
src/main/routers/comments.py         214    170    21%   36-45, 51-66, 74-92, 100-123, 133-193, 203-277, 289-353, 363-407, 412-417, 421-438
src/main/routers/exercisesTO.py      159    119    25%   20, 37-56, 62-84, 94-122, 130-145, 151-186, 192-229, 235-269, 274-281, 285-293, 297-301
src/main/routers/posts.py            187    146    22%   37-46, 52-66, 74-92, 98-144, 150-216, 222-264, 272-299, 304-309, 313-328
src/main/routers/routines.py         197    156    21%   36-45, 51-66, 74-91, 97-148, 154-228, 234-268, 278-305, 310-315, 319-336
src/main/routers/routinesTO.py       214    169    21%   21, 38-61, 67-90, 98-128, 138-160, 166-188, 198-261, 267-297, 303-336, 341-348, 352-364, 370-389, 393-397
src/main/routers/transactions.py      45     26    42%   27-36, 50-65, 79-94
src/main/routers/users.py            233    177    24%   39-69, 77-95, 105-121, 127-136, 142-158, 164-173, 188-202, 208-315, 321-366, 372-381, 391-392, 396-402
src/main/routers/usersTO.py          147     88    40%   40-62, 68-91, 95-111, 119, 145-149, 165-233, 239-282, 313-317
src/main/services/__init__.py          0      0   100%
src/main/services/auth.py             64     29    55%   31, 34, 37-44, 55, 57-58, 68-76, 84-107, 113-122
----------------------------------------------------------------
TOTAL                               1692   1114    34%
Coverage HTML written to dir ./src/tests/target/reports

=========================== short test summary info ============================
FAILED ❌  src/tests/routers/posts_test.py::test_getPosts_NoContent - Asserti...
FAILED ❌  src/tests/routers/posts_test.py::test_getPostById_BadRequest - Ass...
FAILED ❌  src/tests/routers/posts_test.py::test_getPostById_NotFound - Asser...
FAILED ❌  src/tests/routers/posts_test.py::test_getPostByCreator_NotFound - ...
FAILED ❌  src/tests/routers/routines_test.py::test_getRoutines_NoContent - A...
FAILED ❌  src/tests/routers/routines_test.py::test_getRoutineById_BadRequest
FAILED ❌  src/tests/routers/routines_test.py::test_getRoutineById_NotFound
FAILED ❌  src/tests/routers/routines_test.py::test_getRoutineByCreator_NotFound
FAILED ❌  src/tests/routers/usersTO_test.py::test_getUsersTO_NoContent - Ass...
FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTOById_BadRequest
FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTOById_NotFound - A...
FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTOByUsername_NotFound
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExercisesTO_NoContent
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_BadRequest
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_NotFound
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_NotFound
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_NoContent
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTOByName_NotFound
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_addExerciseTO_NotFoundUserTO
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_addExerciseTO_Created
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_addExerciseTO_Conflict
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTO_Ok - fas...
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTOById_Ok
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExercisesTOByCreator_Ok
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_getExerciseTOByName_Ok
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_BadRequest
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_NotFound
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_Conflict
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_updateExerciseTO_Ok - ...
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_BadRequest
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_NotFound
FAILED ❌  src/tests/routers/exercisesTO_test.py::test_deleteExerciseTO_Ok - ...
FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTO_NoContent
FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutineTOById_BadRequest
FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutineTOById_NotFound
FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_NotFound
FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_NoContent
FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTOByName_NotFound
FAILED ❌  src/tests/routers/routinesTO_test.py::test_addRoutineTO_NotFoundUserTO
FAILED ❌  src/tests/routers/routinesTO_test.py::test_addRoutineTO_Created - ...
FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutineTO_Ok - fasta...
FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutineTOById_Ok - f...
FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTOByCreator_Ok
FAILED ❌  src/tests/routers/routinesTO_test.py::test_getRoutinesTOByName_Ok
FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_BadRequestRoutineId
FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_BadRequestExerciseId
FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_NotFoundRoutineId
FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_NotFoundExerciseId
FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_Ok
FAILED ❌  src/tests/routers/routinesTO_test.py::test_addExerciseTOToRoutineTO_Conflict
FAILED ❌  src/tests/routers/routinesTO_test.py::test_updateRoutineTO_BadRequest
FAILED ❌  src/tests/routers/routinesTO_test.py::test_updateRoutineTO_NotFound
FAILED ❌  src/tests/routers/routinesTO_test.py::test_updateRoutineTO_Ok - fa...
FAILED ❌  src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_BadRequest
FAILED ❌  src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_NotFound
FAILED ❌  src/tests/routers/routinesTO_test.py::test_deleteRoutineTO_Ok - fa...
FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTO_Ok - fastapi.exc...
FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTOById_Ok - fastapi...
FAILED ❌  src/tests/routers/usersTO_test.py::test_getUserTOByUsername_Ok - f...
FAILED ❌  src/tests/routers/usersTO_test.py::test_updateUserTO_BadRequest - ...
FAILED ❌  src/tests/routers/usersTO_test.py::test_updateUserTO_NotFound - As...
FAILED ❌  src/tests/routers/usersTO_test.py::test_updateUserTO_Conflict - As...
FAILED ❌  src/tests/routers/usersTO_test.py::test_updateUserTO_Ok - fastapi....
FAILED ❌  src/tests/routers/usersTO_test.py::test_deleteUserTO_BadRequest - ...
FAILED ❌  src/tests/routers/usersTO_test.py::test_deleteUserTO_NotFound - As...
FAILED ❌  src/tests/routers/usersTO_test.py::test_deleteUserTO_Ok - fastapi....
FAILED ❌  src/tests/routers/users_test.py::test_addUser_Created - fastapi.ex...
FAILED ❌  src/tests/routers/posts_test.py::test_getPostByCreator_NoContent
FAILED ❌  src/tests/routers/posts_test.py::test_addPost_NotFound - Assertion...
FAILED ❌  src/tests/routers/posts_test.py::test_addPost_Created - fastapi.ex...
FAILED ❌  src/tests/routers/comments_test.py::test_getComments_NoContent - A...
FAILED ❌  src/tests/routers/comments_test.py::test_getCommentById_BadRequest
FAILED ❌  src/tests/routers/comments_test.py::test_getCommentById_NotFound
FAILED ❌  src/tests/routers/comments_test.py::test_getCommentsByCreator_NotFound
FAILED ❌  src/tests/routers/comments_test.py::test_getCommentsByCreator_NoContent
FAILED ❌  src/tests/routers/comments_test.py::test_getPostComments_BadRequest
FAILED ❌  src/tests/routers/comments_test.py::test_getPostComments_NotFound
FAILED ❌  src/tests/routers/comments_test.py::test_getPostComments_NoContent
FAILED ❌  src/tests/routers/comments_test.py::test_addCommentToPost_PostIdBadRequest
FAILED ❌  src/tests/routers/comments_test.py::test_addCommentToPost_PostNotFound
FAILED ❌  src/tests/routers/comments_test.py::test_addCommentToPost_UserNotFound
FAILED ❌  src/tests/routers/comments_test.py::test_addCommentToPost_Ok - Nam...
FAILED ❌  src/tests/routers/comments_test.py::test_getComments_Ok - fastapi....
FAILED ❌  src/tests/routers/comments_test.py::test_getCommentById_Ok - fasta...
FAILED ❌  src/tests/routers/comments_test.py::test_getCommentsByCreator_Ok
FAILED ❌  src/tests/routers/comments_test.py::test_getPostComments_Ok - fast...
FAILED ❌  src/tests/routers/comments_test.py::test_udpateCommentFromPost_BadRequest
FAILED ❌  src/tests/routers/comments_test.py::test_udpateCommentFromPost_CommentNotFound
FAILED ❌  src/tests/routers/comments_test.py::test_udpateCommentFromPost_PostNotFound
FAILED ❌  src/tests/routers/comments_test.py::test_udpateCommentFromPost_UserNotFound
FAILED ❌  src/tests/routers/comments_test.py::test_udpateCommentFromPost_Ok
FAILED ❌  src/tests/routers/comments_test.py::test_deleteCommentFromPost_BadRequest
FAILED ❌  src/tests/routers/comments_test.py::test_deleteCommentFromPost_CommentNotFound
FAILED ❌  src/tests/routers/comments_test.py::test_deleteCommentFromPost_Ok
FAILED ❌  src/tests/routers/comments_test.py::test_deleteAllPostComments_BadRequest
FAILED ❌  src/tests/routers/comments_test.py::test_deleteAllPostComments_NotFound
FAILED ❌  src/tests/routers/comments_test.py::test_deleteAllPostComments_Ok
FAILED ❌  src/tests/routers/comments_test.py::test_deleteAllPostComments_NoContent
FAILED ❌  src/tests/routers/posts_test.py::test_getPosts_Ok - fastapi.except...
FAILED ❌  src/tests/routers/posts_test.py::test_getPostById_Ok - NameError: ...
FAILED ❌  src/tests/routers/posts_test.py::test_getPostsByCreator_Ok - fasta...
FAILED ❌  src/tests/routers/posts_test.py::test_updatePost_BadRequest - Asse...
FAILED ❌  src/tests/routers/posts_test.py::test_updatePost_NotFound - Assert...
FAILED ❌  src/tests/routers/posts_test.py::test_updatePost_NoContent - NameE...
FAILED ❌  src/tests/routers/posts_test.py::test_updatePost_User_NotFound - N...
FAILED ❌  src/tests/routers/posts_test.py::test_updatePost_Created - NameErr...
FAILED ❌  src/tests/routers/posts_test.py::test_deletePost_BadRequest - Asse...
FAILED ❌  src/tests/routers/posts_test.py::test_deletePost_NotFound - Assert...
FAILED ❌  src/tests/routers/posts_test.py::test_deletePost_Ok - NameError: n...
FAILED ❌  src/tests/routers/posts_test.py::test_deleteAllCreatorPosts_NotFound
FAILED ❌  src/tests/routers/posts_test.py::test_deleteAllCreatorPosts_Ok - f...
FAILED ❌  src/tests/routers/routines_test.py::test_getRoutineByCreator_NoContent
FAILED ❌  src/tests/routers/routines_test.py::test_addRoutine_NotFound - Ass...
FAILED ❌  src/tests/routers/routines_test.py::test_addRoutine_Created - fast...
FAILED ❌  src/tests/routers/routines_test.py::test_getRoutines_Ok - fastapi....
FAILED ❌  src/tests/routers/routines_test.py::test_getRoutineById_Ok - NameE...
FAILED ❌  src/tests/routers/routines_test.py::test_getRoutinesByCreator_Ok
FAILED ❌  src/tests/routers/routines_test.py::test_updateRoutine_BadRequest
FAILED ❌  src/tests/routers/routines_test.py::test_updateRoutine_NotFound - ...
FAILED ❌  src/tests/routers/routines_test.py::test_updateRoutine_NoContent
FAILED ❌  src/tests/routers/routines_test.py::test_updateRoutine_UserNotFound
FAILED ❌  src/tests/routers/routines_test.py::test_updateRoutine_Created - N...
FAILED ❌  src/tests/routers/routines_test.py::test_deleteRoutine_BadRequest
FAILED ❌  src/tests/routers/routines_test.py::test_deleteRoutine_NotFound - ...
FAILED ❌  src/tests/routers/routines_test.py::test_deleteRoutine_Ok - NameEr...
FAILED ❌  src/tests/routers/routines_test.py::test_deleteAllCreatorRoutines_NotFound
FAILED ❌  src/tests/routers/routines_test.py::test_deleteAllCreatorRoutines_Ok
FAILED ❌  src/tests/routers/users_test.py::test_getPublicUsers_BadRequest - ...
FAILED ❌  src/tests/routers/users_test.py::test_getPublicUsers_All_Ok - fast...
FAILED ❌  src/tests/routers/users_test.py::test_getPublicUsers_ById_Ok - fas...
FAILED ❌  src/tests/routers/users_test.py::test_getPublicUsers_ByUsername_Ok
FAILED ❌  src/tests/routers/users_test.py::test_followUser_Ok - fastapi.exce...
FAILED ❌  src/tests/routers/users_test.py::test_followUser_NoContent - Asser...
FAILED ❌  src/tests/routers/users_test.py::test_unfollowUser_Ok - fastapi.ex...
FAILED ❌  src/tests/routers/users_test.py::test_unfollowUser_NoContent - Ass...
FAILED ❌  src/tests/routers/users_test.py::test_getUsers_Ok - fastapi.except...
FAILED ❌  src/tests/routers/users_test.py::test_getUserById_Ok - NameError: ...
FAILED ❌  src/tests/routers/users_test.py::test_getUserById_BadRequest - Ass...
FAILED ❌  src/tests/routers/users_test.py::test_getUserById_NotFound - Asser...
FAILED ❌  src/tests/routers/users_test.py::test_getUserByUsername_Ok - fasta...
FAILED ❌  src/tests/routers/users_test.py::test_updateUser_NoContent - NameE...
FAILED ❌  src/tests/routers/users_test.py::test_updateUser_Ok - NameError: n...
FAILED ❌  src/tests/routers/users_test.py::test_getUserByUsername_NotFound
FAILED ❌  src/tests/routers/users_test.py::test_updateUser_BadRequest - Asse...
FAILED ❌  src/tests/routers/users_test.py::test_updateUser_NotFound - Assert...
FAILED ❌  src/tests/routers/users_test.py::test_updateUser_Conflict - NameEr...
FAILED ❌  src/tests/routers/users_test.py::test_deleteUser_Ok - fastapi.exce...
FAILED ❌  src/tests/routers/users_test.py::test_deleteUser_BadRequest - Asse...
FAILED ❌  src/tests/routers/users_test.py::test_deleteUser_NotFound - Assert...
FAILED ❌  src/tests/routers/users_test.py::test_deleteAllUsers_Ok - fastapi....
FAILED ❌  src/tests/routers/users_test.py::test_getUsers_NoContent - Asserti...
======================== 151 failed, 3 passed in 6.53s =========================
